```
code/backend/.env.example
```
# Database Configuration (PostgreSQL Example)
DB_HOST=localhost
DB_PORT=5432
DB_NAME=handmade_crafts_db
DB_USER=your_db_user
DB_PASSWORD=your_db_password

# JWT Secret for Authentication
JWT_SECRET=your_super_secret_jwt_key

# Server Port
PORT=5000

# Placeholder for File Storage (e.g., AWS S3 credentials)
# AWS_S3_BUCKET_NAME=your-s3-bucket
# AWS_ACCESS_KEY_ID=your-access-key-id
# AWS_SECRET_ACCESS_KEY=your-secret-access-key

# Placeholder for Payment Gateway (e.g., Stripe secret key)
# STRIPE_SECRET_KEY=sk_test_...

# Placeholder for Email Service Credentials
# EMAIL_HOST=smtp.your-email-provider.com
# EMAIL_PORT=587
# EMAIL_USER=your-email-address
# EMAIL_PASS=your-email-password
```

```
code/backend/.gitignore
```
node_modules/
.env
npm-debug.log
dist/
coverage/
*.sqlite
*.sql
/uploads # if storing uploads locally

```

```
code/backend/package.json
```
{
  "name": "handmade-crafts-backend",
  "version": "1.0.0",
  "description": "Backend for the Handmade Crafts E-commerce platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "migrate": "sequelize db:migrate",
    "seed": "sequelize db:seed:all",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "ecommerce",
    "handmade",
    "crafts",
    "backend",
    "nodejs",
    "express",
    "sequelize",
    "postgresql"
  ],
  "author": "Your Name",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "pg": "^8.11.3",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.35.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "sequelize-cli": "^6.6.2"
  }
}
```

```
code/backend/server.js
```
require('dotenv').config(); // Load environment variables from .env file
const app = require('./src/app');
const { sequelize } = require('./src/models'); // Import sequelize instance

const PORT = process.env.PORT || 5000;

// Sync Database and start server
sequelize.sync({ force: false }) // `force: true` will drop and re-create tables on every app start (useful for development, use with caution)
    .then(() => {
        console.log('Database synced successfully.');
        app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}`);
            console.log(`Access API at http://localhost:${PORT}/api/v1`);
        });
    })
    .catch(err => {
        console.error('Unable to sync database:', err);
        process.exit(1); // Exit process with failure
    });

```

```
code/backend/src/app.js
```
const express = require('express');
const cors = require('cors');
const routes = require('./routes'); // Import index route file
const errorHandler = require('./utils/errorHandler'); // Import basic error handler

const app = express();

// Middleware
app.use(cors()); // Enable CORS for all origins (adjust in production)
app.use(express.json()); // Parse JSON request bodies
app.use(express.urlencoded({ extended: true })); // Parse URL-encoded request bodies

// Serve static files (optional, for local uploads if not using cloud storage)
// app.use('/uploads', express.static('uploads'));

// API Routes
app.use('/api/v1', routes); // Mount all routes under /api/v1

// Basic Health Check Route
app.get('/api/v1/health', (req, res) => {
    res.status(200).json({ status: 'ok', message: 'API is healthy' });
});

// Catch-all for undefined routes
app.use((req, res, next) => {
    const error = new Error(`Not Found - ${req.originalUrl}`);
    error.status = 404;
    next(error); // Pass to error handler
});

// Error Handling Middleware
app.use(errorHandler);

module.exports = app;
```

```
code/backend/src/config/config.js
```
module.exports = {
    development: {
        username: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: 'postgres', // Or 'mysql', 'sqlite', 'mssql'
        logging: console.log, // Enable Sequelize logging in development
        dialectOptions: {
            // ssl: {
            //     require: true,
            //     rejectUnauthorized: false // Only for self-signed certs or development
            // }
        }
    },
    test: {
        // Configuration for test environment
    },
    production: {
        username: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: 'postgres',
        logging: false, // Disable logging in production
        dialectOptions: {
            ssl: {
                require: true,
                rejectUnauthorized: false // Or true, depending on your DB provider's SSL cert
            }
        }
    },
    jwt: {
        secret: process.env.JWT_SECRET,
        expiresIn: '1d' // Token expiry time
    },
    // Add other configurations like file storage, payment gateway keys here
};
```

```
code/backend/src/controllers/adminController.js
```
const adminService = require('../services/adminService');

exports.getAllUsers = async (req, res, next) => {
    try {
        // TODO: Implement pagination, filtering, sorting
        const users = await adminService.findAllUsers();
        res.status(200).json(users);
    } catch (error) {
        next(error);
    }
};

exports.getUserById = async (req, res, next) => {
    try {
        const user = await adminService.findUserById(req.params.userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.status(200).json(user);
    } catch (error) {
        next(error);
    }
};

exports.updateUser = async (req, res, next) => {
    try {
        // TODO: Sanitize input, prevent updating sensitive fields directly without admin approval
        const updatedUser = await adminService.updateUser(req.params.userId, req.body);
        if (!updatedUser) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.status(200).json(updatedUser);
    } catch (error) {
        next(error);
    }
};

exports.deleteUser = async (req, res, next) => {
    try {
        const success = await adminService.deleteUser(req.params.userId);
        if (!success) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.status(200).json({ message: 'User deleted successfully' });
    } catch (error) {
        next(error);
    }
};

exports.getAllProducts = async (req, res, next) => {
     try {
        // TODO: Implement pagination, filtering (e.g., by status: pending, approved, rejected), sorting
        const products = await adminService.findAllProducts();
        res.status(200).json(products);
    } catch (error) {
        next(error);
    }
};

exports.getProductById = async (req, res, next) => {
     try {
        const product = await adminService.findProductById(req.params.productId);
        if (!product) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json(product);
    } catch (error) {
        next(error);
    }
};

exports.moderateProduct = async (req, res, next) => {
    try {
        // Expecting status update in req.body, e.g., { isActive: true } or { moderationStatus: 'approved' }
        // TODO: Validate input status/fields
        const moderatedProduct = await adminService.moderateProduct(req.params.productId, req.body);
        if (!moderatedProduct) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json(moderatedProduct);
    } catch (error) {
        next(error);
    }
};

exports.deleteProduct = async (req, res, next) => {
    try {
        const success = await adminService.deleteProduct(req.params.productId);
        if (!success) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json({ message: 'Product deleted successfully' });
    } catch (error) {
        next(error);
    }
};

exports.getAllOrders = async (req, res, next) => {
    try {
        // TODO: Implement pagination, filtering, sorting
        const orders = await adminService.findAllOrders();
        res.status(200).json(orders);
    } catch (error) {
        next(error);
    }
};

exports.getOrderById = async (req, res, next) => {
    try {
        const order = await adminService.findOrderById(req.params.orderId);
        if (!order) {
            return res.status(404).json({ message: 'Order not found' });
        }
        res.status(200).json(order);
    } catch (error) {
        next(error);
    }
};

exports.updateOrderStatus = async (req, res, next) => {
    try {
         // Expecting status update in req.body, e.g., { status: 'Shipped' }
        // TODO: Validate input status
        const updatedOrder = await adminService.updateOrderStatus(req.params.orderId, req.body.status);
        if (!updatedOrder) {
            return res.status(404).json({ message: 'Order not found' });
        }
        res.status(200).json(updatedOrder);
    } catch (error) {
        next(error);
    }
};

// TODO: Implement Category Management endpoints (list, create, update, delete)
```

```
code/backend/src/controllers/authController.js
```
const authService = require('../services/authService');
const { generateToken } = require('../utils/authUtils'); // Assuming token generation is a utility

exports.registerUser = async (req, res, next) => {
    try {
        // TODO: Add input validation (e.g., Joi or Express-validator)
        const { email, password, name, role, shopName } = req.body;

        if (!email || !password || !name || !role) {
            return res.status(400).json({ message: 'Email, password, name, and role are required' });
        }
        if (role === 'seller' && !shopName) {
             return res.status(400).json({ message: 'Shop name is required for sellers' });
        }

        const newUser = await authService.register(email, password, name, role, shopName);

        // Optionally log the user in immediately after registration
        const token = generateToken(newUser.id, newUser.role); // Generate JWT
        // Don't return password hash
        const userResponse = newUser.toJSON();
        delete userResponse.passwordHash;

        res.status(201).json({
            message: 'User registered successfully',
            user: userResponse,
            token
        });
    } catch (error) {
        // Handle specific errors, e.g., duplicate email
        if (error.message === 'Email already exists') {
            return res.status(409).json({ message: error.message });
        }
        next(error); // Pass other errors to the error handler
    }
};

exports.loginUser = async (req, res, next) => {
    try {
        // TODO: Add input validation
        const { email, password } = req.body;

         if (!email || !password) {
            return res.status(400).json({ message: 'Email and password are required' });
        }

        const user = await authService.login(email, password);

        if (!user) {
            // Use a generic message for security
            return res.status(401).json({ message: 'Invalid credentials' });
        }

        const token = generateToken(user.id, user.role); // Generate JWT

        // Don't return password hash
        const userResponse = user.toJSON();
        delete userResponse.passwordHash;

        res.status(200).json({
            message: 'Login successful',
            user: userResponse,
            token
        });
    } catch (error) {
        next(error);
    }
};

// TODO: Implement logout (server-side token invalidation is complex for JWT without a token list, often handled by client deleting token)
// TODO: Implement password reset (forgot password, reset password)
```

```
code/backend/src/controllers/orderController.js
```
const orderService = require('../services/orderService');
// const paymentService = require('../services/paymentService'); // Assuming a payment service exists

exports.createOrder = async (req, res, next) => {
    try {
        // TODO: Input validation for cart items and shipping address
        const customerId = req.user.id; // Get user ID from authenticated request
        const { cartItems, shippingAddress, paymentMethodId } = req.body; // paymentMethodId would come from gateway SDK

        if (!cartItems || cartItems.length === 0 || !shippingAddress || !paymentMethodId) {
             return res.status(400).json({ message: 'Cart items, shipping address, and payment method are required' });
        }

        // TODO: Validate cart items against current stock and prices
        // This is crucial to prevent users ordering outdated stock/prices

        // TODO: Process payment using paymentMethodId via paymentService
        // const paymentResult = await paymentService.processPayment(totalAmount, paymentMethodId);
        // if (!paymentResult.success) {
        //     return res.status(400).json({ message: 'Payment failed', details: paymentResult.error });
        // }

        const order = await orderService.createOrder(customerId, cartItems, shippingAddress); // Pass payment details if needed

        // TODO: Send order confirmation email to customer and new order notification to seller(s)

        // TODO: Clear the user's cart (if cart is stored server-side/DB)

        res.status(201).json({
            message: 'Order created successfully',
            orderId: order.id,
            // paymentStatus: paymentResult.status // Include payment status
        });
    } catch (error) {
        next(error);
    }
};

exports.getCustomerOrders = async (req, res, next) => {
    try {
        const customerId = req.user.id;
        // TODO: Implement pagination, sorting
        const orders = await orderService.findOrdersByCustomerId(customerId);
        res.status(200).json(orders);
    } catch (error) {
        next(error);
    }
};

exports.getSellerOrders = async (req, res, next) => {
     try {
        const sellerId = req.user.sellerId; // Assuming sellerId is attached to user object after authentication
        if (!sellerId) {
            return res.status(403).json({ message: 'User is not a seller' });
        }
        // TODO: Implement pagination, sorting, filtering by status
        const orders = await orderService.findOrdersBySellerId(sellerId);
        res.status(200).json(orders);
    } catch (error) {
        next(error);
    }
};

exports.getOrderDetails = async (req, res, next) => {
    try {
        const orderId = req.params.orderId;
        const userId = req.user.id;
        const userRole = req.user.role;
        const sellerId = req.user.sellerId; // If user is a seller

        const order = await orderService.findOrderById(orderId);

        if (!order) {
            return res.status(404).json({ message: 'Order not found' });
        }

        // Ensure user is authorized to view this order (customer, seller of items in order, or admin)
        const isCustomer = order.customerId === userId;
        // Check if the user is a seller involved in this order
        const isSeller = userRole === 'seller' && order.OrderItems.some(item => item.Product.sellerId === sellerId);
        const isAdmin = userRole === 'admin';

        if (!isCustomer && !isSeller && !isAdmin) {
            return res.status(403).json({ message: 'Unauthorized to view this order' });
        }

        res.status(200).json(order);
    } catch (error) {
        next(error);
    }
};

exports.updateOrderStatus = async (req, res, next) => {
    try {
        const orderId = req.params.orderId;
        const sellerId = req.user.sellerId; // Only sellers or admin can update status
        const userRole = req.user.role;
        const { status, trackingNumber } = req.body; // Allow updating status and adding tracking

        if (!status) {
             return res.status(400).json({ message: 'Status is required' });
        }

        // TODO: Validate allowed status transitions based on current status and user role
        // e.g., 'Processing' -> 'Shipped' (Seller/Admin), 'Shipped' -> 'Delivered' (Customer/Admin?)

        const updatedOrder = await orderService.updateOrderStatus(orderId, status, trackingNumber, sellerId, userRole);

        if (!updatedOrder) {
             // This might mean order not found OR seller is not authorized for this specific order/item
             // Differentiate responses for security
             return res.status(403).json({ message: 'Unauthorized or Order not found' });
        }

        // TODO: Send email notification based on status change (e.g., Order Shipped)

        res.status(200).json(updatedOrder);
    } catch (error) {
        next(error);
    }
};
```

```
code/backend/src/controllers/productController.js
```
const productService = require('../services/productService');

exports.getProducts = async (req, res, next) => {
    try {
        // Extract query parameters for search, filter, sort, pagination
        const { q, category, minPrice, maxPrice, sortBy, order, page = 1, limit = 10 } = req.query;
        const filters = { category, minPrice, maxPrice };
        const search = q;
        const sort = { by: sortBy, order };
        const pagination = { page: parseInt(page, 10), limit: parseInt(limit, 10) };

        // TODO: Sanitize and validate query parameters

        const { products, totalCount } = await productService.findProducts({ search, filters, sort, pagination });

        res.status(200).json({
            products,
            totalCount,
            page: pagination.page,
            limit: pagination.limit,
            totalPages: Math.ceil(totalCount / pagination.limit)
        });
    } catch (error) {
        next(error);
    }
};

exports.getProductById = async (req, res, next) => {
    try {
        const product = await productService.findProductById(req.params.productId);
        if (!product) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json(product);
    } catch (error) {
        next(error);
    }
};

exports.createProduct = async (req, res, next) => {
    try {
        // TODO: Add input validation
        const sellerId = req.user.sellerId; // Get seller ID from authenticated seller user
        if (!sellerId) {
            return res.status(403).json({ message: 'Only sellers can create products' });
        }

        const productData = req.body;
        // req.files will contain uploaded images if using multer
        const images = req.files;

        if (!productData.name || !productData.price || !productData.categoryId || !productData.stock) {
             return res.status(400).json({ message: 'Name, price, category, and stock are required' });
        }

        const newProduct = await productService.createProduct(sellerId, productData, images); // Pass images to service

        res.status(201).json({
            message: 'Product created successfully',
            product: newProduct
        });
    } catch (error) {
        next(error);
    }
};

exports.updateProduct = async (req, res, next) => {
    try {
        // TODO: Add input validation
        const sellerId = req.user.sellerId; // Get seller ID from authenticated seller user
        if (!sellerId) {
            return res.status(403).json({ message: 'Only sellers can update products' });
        }

        const productId = req.params.productId;
        const productData = req.body;
        const images = req.files; // New images to upload/replace

        const updatedProduct = await productService.updateProduct(productId, sellerId, productData, images);

        if (!updatedProduct) {
            // This might mean product not found OR product does not belong to the seller
             return res.status(403).json({ message: 'Unauthorized or Product not found' });
        }

        res.status(200).json({
             message: 'Product updated successfully',
             product: updatedProduct
        });
    } catch (error) {
        next(error);
    }
};

exports.deleteProduct = async (req, res, next) => {
     try {
        const sellerId = req.user.sellerId; // Get seller ID from authenticated seller user
        if (!sellerId) {
            return res.status(403).json({ message: 'Only sellers can delete products' });
        }

        const productId = req.params.productId;

        const success = await productService.deleteProduct(productId, sellerId);

        if (!success) {
            // This might mean product not found OR product does not belong to the seller
            return res.status(403).json({ message: 'Unauthorized or Product not found' });
        }

        res.status(200).json({ message: 'Product deleted successfully' });
    } catch (error) {
        next(error);
    }
};

exports.getCategories = async (req, res, next) => {
     try {
        const categories = await productService.findAllCategories();
        res.status(200).json(categories);
    } catch (error) {
        next(error);
    }
};

// TODO: Add endpoints for managing product images (upload, delete specific images)
// TODO: Add endpoint for getting products by seller
// TODO: Add endpoint for featured products
```

```
code/backend/src/controllers/reviewController.js
```
const reviewService = require('../services/reviewService');
// const orderService = require('../services/orderService'); // Need order service to verify purchase

exports.getReviewsForProduct = async (req, res, next) => {
    try {
        const productId = req.params.productId;
        // TODO: Implement pagination, sorting for reviews
        const reviews = await reviewService.findReviewsByProductId(productId);
        res.status(200).json(reviews);
    } catch (error) {
        next(error);
    }
};

exports.createReview = async (req, res, next) => {
    try {
        // TODO: Add input validation (rating is required, comment is optional)
        const customerId = req.user.id; // Must be logged in
        const productId = req.params.productId;
        const { rating, comment } = req.body;

        if (!rating) {
             return res.status(400).json({ message: 'Rating is required' });
        }
        if (rating < 1 || rating > 5) {
             return res.status(400).json({ message: 'Rating must be between 1 and 5' });
        }

        // TODO: Crucial check: Verify that the customer has actually purchased this product
        // const hasPurchased = await orderService.hasCustomerPurchasedProduct(customerId, productId);
        // if (!hasPurchased) {
        //     return res.status(403).json({ message: 'You can only review products you have purchased' });
        // }

        const newReview = await reviewService.createReview(productId, customerId, rating, comment);

        // TODO: Update product's average rating and review count (can be done asynchronously)

        res.status(201).json({
            message: 'Review submitted successfully',
            review: newReview
        });
    } catch (error) {
        // Handle potential duplicate review error if enforcing one review per purchase
         if (error.message === 'Customer has already reviewed this product') { // Or similar check
             return res.status(409).json({ message: error.message });
         }
        next(error);
    }
};

// TODO: Implement updateReview (allow user to edit their own review)
// TODO: Implement deleteReview (allow user to delete their own review, or admin to delete any)
```

```
code/backend/src/controllers/userController.js
```
const userService = require('../services/userService');
// const orderService = require('../services/orderService'); // To fetch user's orders
// const reviewService = require('../services/reviewService'); // To fetch user's reviews
// const productService = require('../services/productService'); // To fetch seller's products

exports.getUserProfile = async (req, res, next) => {
    try {
        const userId = req.user.id; // Get ID from authenticated user

        const user = await userService.findUserById(userId);

        if (!user) {
            // This case should theoretically not happen if auth middleware works correctly
            return res.status(404).json({ message: 'User profile not found' });
        }

        // Don't return password hash
        const userResponse = user.toJSON();
        delete userResponse.passwordHash;

        // TODO: Depending on role, fetch related data (orders for customer, products/orders for seller)
        // if (user.role === 'customer') {
        //     userResponse.recentOrders = await orderService.findRecentOrdersByCustomerId(userId);
        //     userResponse.reviews = await reviewService.findReviewsByCustomerId(userId);
        //     // userResponse.wishlist = ...
        // } else if (user.role === 'seller') {
        //     userResponse.shopInfo = await userService.findSellerProfileByUserId(userId); // Assuming a seller profile exists
        //     userResponse.products = await productService.findProductsBySellerId(userResponse.shopInfo.id);
        //     userResponse.recentOrders = await orderService.findRecentOrdersBySellerId(userResponse.shopInfo.id);
        //     // userResponse.salesSummary = ...
        // }

        res.status(200).json(userResponse);
    } catch (error) {
        next(error);
    }
};

exports.updateUserProfile = async (req, res, next) => {
    try {
        const userId = req.user.id;
        // TODO: Add input validation, restrict fields that can be updated by the user (e.g., role, email without verification)
        const updateData = req.body;

        const updatedUser = await userService.updateUser(userId, updateData);

        if (!updatedUser) {
             return res.status(404).json({ message: 'User profile not found' });
        }

        // Don't return password hash
        const userResponse = updatedUser.toJSON();
        delete userResponse.passwordHash;

        res.status(200).json({
             message: 'Profile updated successfully',
             user: userResponse
        });
    } catch (error) {
        next(error);
    }
};

// TODO: Add endpoints for specific user actions like managing wishlist (if server-side)
// TODO: Add endpoint for sellers to update their specific shop profile (description, image etc.)
```

```
code/backend/src/middleware/authMiddleware.js
```
const jwt = require('jsonwebtoken');
const config = require('../config/config');
const { User, Seller } = require('../models'); // Assuming User and Seller models exist

// Middleware to protect routes - verify JWT and attach user
exports.protect = async (req, res, next) => {
    let token;

    // Check for token in headers (standard for Bearer Token)
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        // Format looks like: Bearer TOKEN
        token = req.headers.authorization.split(' ')[1];
    }
    // TODO: Could also check for token in cookies or query params if needed

    if (!token) {
        return res.status(401).json({ message: 'Not authorized, no token provided' });
    }

    try {
        // Verify token
        const decoded = jwt.verify(token, config.jwt.secret);

        // Find user by ID from token payload
        const user = await User.findByPk(decoded.id, {
            attributes: ['id', 'email', 'name', 'role'], // Select specific fields, exclude password hash
            include: { model: Seller, as: 'seller' } // Include seller info if user is a seller
        });

        if (!user) {
            return res.status(401).json({ message: 'Not authorized, user not found' });
        }

        // Attach user object to request
        req.user = {
            id: user.id,
            email: user.email,
            name: user.name,
            role: user.role,
            sellerId: user.seller ? user.seller.id : null // Attach sellerId if applicable
        };

        next(); // Proceed to the next middleware/controller
    } catch (error) {
        console.error('JWT Verification Error:', error.message);
        res.status(401).json({ message: 'Not authorized, token failed' });
    }
};

// Middleware to restrict routes based on role
exports.requireRole = (roles) => {
    // Ensure roles is always an array
    if (!Array.isArray(roles)) {
        roles = [roles];
    }

    return (req, res, next) => {
        // `req.user` should be available from the `protect` middleware
        if (!req.user || !req.user.role) {
             // This case implies `protect` middleware wasn't run or failed before this
             return res.status(500).json({ message: 'Role check failed: User not authenticated' });
        }

        if (!roles.includes(req.user.role)) {
            return res.status(403).json({ message: `Forbidden: Requires one of roles: ${roles.join(', ')}` });
        }

        next(); // User has the required role
    };
};
```

```
code/backend/src/models/index.js
```
const { Sequelize, DataTypes } = require('sequelize');
const config = require('../config/config')[process.env.NODE_ENV || 'development'];

// Database connection setup
const sequelize = new Sequelize(config.database, config.username, config.password, {
    host: config.host,
    port: config.port,
    dialect: config.dialect,
    logging: config.logging,
    dialectOptions: config.dialectOptions
});

// Import models
const User = require('./user')(sequelize, DataTypes);
const Seller = require('./seller')(sequelize, DataTypes);
const Category = require('./category')(sequelize, DataTypes);
const Product = require('./product')(sequelize, DataTypes);
const ProductImage = require('./productimage')(sequelize, DataTypes);
const Order = require('./order')(sequelize, DataTypes);
const OrderItem = require('./orderitem')(sequelize, DataTypes);
const Review = require('./review')(sequelize, DataTypes);

// Define Associations

// User (Customer/Admin) <-> Order (1:M)
User.hasMany(Order, { foreignKey: 'customerId', as: 'orders' });
Order.belongsTo(User, { foreignKey: 'customerId', as: 'customer' });

// User (Seller) <-> Seller (1:1)
User.hasOne(Seller, { foreignKey: 'userId', as: 'seller' });
Seller.belongsTo(User, { foreignKey: 'userId', as: 'user' });

// Seller <-> Product (1:M)
Seller.hasMany(Product, { foreignKey: 'sellerId', as: 'products' });
Product.belongsTo(Seller, { foreignKey: 'sellerId', as: 'seller' });

// Category <-> Product (1:M)
Category.hasMany(Product, { foreignKey: 'categoryId', as: 'products' });
Product.belongsTo(Category, { foreignKey: 'categoryId', as: 'category' });

// Product <-> ProductImage (1:M)
Product.hasMany(ProductImage, { foreignKey: 'productId', as: 'images' });
ProductImage.belongsTo(Product, { foreignKey: 'productId', as: 'product' });

// Order <-> OrderItem (1:M)
Order.hasMany(OrderItem, { foreignKey: 'orderId', as: 'items' });
OrderItem.belongsTo(Order, { foreignKey: 'orderId', as: 'order' });

// Product <-> OrderItem (1:M) - An OrderItem contains one Product
Product.hasMany(OrderItem, { foreignKey: 'productId', as: 'orderItems' }); // Optional: allows finding order items for a product
OrderItem.belongsTo(Product, { foreignKey: 'productId', as: 'product' });

// User (Customer) <-> Review (1:M)
User.hasMany(Review, { foreignKey: 'customerId', as: 'reviews' });
Review.belongsTo(User, { foreignKey: 'customerId', as: 'customer' });

// Product <-> Review (1:M)
Product.hasMany(Review, { foreignKey: 'productId', as: 'reviews' });
Review.belongsTo(Product, { foreignKey: 'productId', as: 'product' });


// Export models and sequelize instance
module.exports = {
    sequelize,
    User,
    Seller,
    Category,
    Product,
    ProductImage,
    Order,
    OrderItem,
    Review,
    // Add other models here
};

// Optional: Authenticate database connection on load
sequelize.authenticate()
    .then(() => {
        console.log('Database connection has been established successfully.');
    })
    .catch(err => {
        console.error('Unable to connect to the database:', err);
    });
```

```
code/backend/src/models/category.js
```
module.exports = (sequelize, DataTypes) => {
    const Category = sequelize.define('Category', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true
        },
        description: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'categories'
    });

    // Associations defined in index.js
    // Category.associate = (models) => {
    //     Category.hasMany(models.Product, { foreignKey: 'categoryId', as: 'products' });
    // };

    return Category;
};
```

```
code/backend/src/models/order.js
```
module.exports = (sequelize, DataTypes) => {
    const Order = sequelize.define('Order', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        customerId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'users', // refers to table name
                key: 'id'
            }
        },
        orderDate: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        status: {
            type: DataTypes.ENUM('Pending', 'Processing', 'Shipped', 'Delivered', 'Cancelled'),
            allowNull: false,
            defaultValue: 'Pending'
        },
        shippingAddress: {
            type: DataTypes.JSONB, // Store address as JSON
            allowNull: false
        },
        paymentStatus: {
            type: DataTypes.ENUM('Pending', 'Paid', 'Failed', 'Refunded'),
            allowNull: false,
            defaultValue: 'Pending'
        },
        totalAmount: {
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false
             // This should be calculated and stored at order creation time
        },
        trackingNumber: {
            type: DataTypes.STRING,
            allowNull: true
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'orders'
    });

    // Associations defined in index.js
    // Order.associate = (models) => {
    //     Order.belongsTo(models.User, { foreignKey: 'customerId', as: 'customer' });
    //     Order.hasMany(models.OrderItem, { foreignKey: 'orderId', as: 'items' });
    // };

    return Order;
};
```

```
code/backend/src/models/orderitem.js
```
module.exports = (sequelize, DataTypes) => {
    const OrderItem = sequelize.define('OrderItem', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        orderId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'orders', // refers to table name
                key: 'id'
            }
        },
        productId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'products', // refers to table name
                key: 'id'
            }
        },
        quantity: {
            type: DataTypes.INTEGER,
            allowNull: false,
            validate: {
                min: 1
            }
        },
        priceAtOrder: { // Price of the product at the time the order was placed
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false
        },
        // Optionally store variations selected at order time as JSONB
        // variations: {
        //     type: DataTypes.JSONB,
        //     allowNull: true
        // },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'order_items'
    });

    // Associations defined in index.js
    // OrderItem.associate = (models) => {
    //     OrderItem.belongsTo(models.Order, { foreignKey: 'orderId', as: 'order' });
    //     OrderItem.belongsTo(models.Product, { foreignKey: 'productId', as: 'product' });
    // };

    return OrderItem;
};
```

```
code/backend/src/models/product.js
```
module.exports = (sequelize, DataTypes) => {
    const Product = sequelize.define('Product', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        sellerId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'sellers', // refers to table name
                key: 'id'
            }
        },
        categoryId: {
            type: DataTypes.INTEGER,
            allowNull: false,
             references: {
                model: 'categories', // refers to table name
                key: 'id'
            }
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false
        },
        description: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        price: {
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false,
            validate: {
                min: 0
            }
        },
        stock: {
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 0,
             validate: {
                min: 0
            }
        },
        // status for admin moderation (e.g., 'pending', 'approved', 'rejected')
        moderationStatus: {
            type: DataTypes.ENUM('Pending', 'Approved', 'Rejected'),
            allowNull: false,
            defaultValue: 'Pending'
        },
        isActive: { // Set to true by admin after approval, can be set false by seller (draft/inactive)
            type: DataTypes.BOOLEAN,
            allowNull: false,
            defaultValue: false
        },
        // Optional: Store variations like size, color as JSONB
        // variations: {
        //     type: DataTypes.JSONB,
        //     allowNull: true
        // },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'products'
    });

    // Associations defined in index.js
    // Product.associate = (models) => {
    //     Product.belongsTo(models.Seller, { foreignKey: 'sellerId', as: 'seller' });
    //     Product.belongsTo(models.Category, { foreignKey: 'categoryId', as: 'category' });
    //     Product.hasMany(models.ProductImage, { foreignKey: 'productId', as: 'images' });
    //     Product.hasMany(models.OrderItem, { foreignKey: 'productId', as: 'orderItems' }); // Optional
    //     Product.hasMany(models.Review, { foreignKey: 'productId', as: 'reviews' });
    // };

    return Product;
};
```

```
code/backend/src/models/productimage.js
```
module.exports = (sequelize, DataTypes) => {
    const ProductImage = sequelize.define('ProductImage', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        productId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'products', // refers to table name
                key: 'id'
            }
        },
        imageUrl: {
            type: DataTypes.STRING, // URL to the image stored in S3 or locally
            allowNull: false,
            validate: {
                isUrl: true // Basic URL validation
            }
        },
        // Optional: Store public ID if using a service like Cloudinary
        // publicId: {
        //     type: DataTypes.STRING,
        //     allowNull: true
        // },
        order: { // To maintain display order of images
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 0
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'product_images'
    });

    // Associations defined in index.js
    // ProductImage.associate = (models) => {
    //     ProductImage.belongsTo(models.Product, { foreignKey: 'productId', as: 'product' });
    // };

    return ProductImage;
};
```

```
code/backend/src/models/review.js
```
module.exports = (sequelize, DataTypes) => {
    const Review = sequelize.define('Review', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        productId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'products', // refers to table name
                key: 'id'
            }
        },
        customerId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'users', // refers to table name
                key: 'id'
            }
        },
        rating: {
            type: DataTypes.INTEGER,
            allowNull: false,
            validate: {
                min: 1,
                max: 5
            }
        },
        comment: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        reviewDate: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'reviews',
        indexes: [
            // Prevent a customer from reviewing the same product multiple times
            // unless business logic allows it (e.g., one review per purchase)
            // The purchase check needs to be in the service/controller logic.
            // A simple unique constraint here would prevent *any* subsequent review by the same user.
            // {
            //     unique: true,
            //     fields: ['productId', 'customerId']
            // }
        ]
    });

    // Associations defined in index.js
    // Review.associate = (models) => {
    //     Review.belongsTo(models.Product, { foreignKey: 'productId', as: 'product' });
    //     Review.belongsTo(models.User, { foreignKey: 'customerId', as: 'customer' });
    // };

    return Review;
};
```

```
code/backend/src/models/seller.js
```
module.exports = (sequelize, DataTypes) => {
    const Seller = sequelize.define('Seller', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        userId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            unique: true, // Each user can only be one seller
            references: {
                model: 'users', // refers to table name
                key: 'id'
            }
        },
        shopName: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true
        },
        description: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        shopImage: { // URL to shop logo/banner
            type: DataTypes.STRING,
            allowNull: true,
             validate: {
                isUrl: true // Basic URL validation
            }
        },
        // Optional: Add other seller-specific info like policies, location, etc.
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'sellers'
    });

    // Associations defined in index.js
    // Seller.associate = (models) => {
    //     Seller.belongsTo(models.User, { foreignKey: 'userId', as: 'user' });
    //     Seller.hasMany(models.Product, { foreignKey: 'sellerId', as: 'products' });
    // };

    return Seller;
};
```

```
code/backend/src/models/user.js
```
module.exports = (sequelize, DataTypes) => {
    const User = sequelize.define('User', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        email: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true,
            validate: {
                isEmail: true
            }
        },
        passwordHash: {
            type: DataTypes.STRING,
            allowNull: false
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false
        },
        role: {
            type: DataTypes.ENUM('customer', 'seller', 'admin'),
            allowNull: false,
            defaultValue: 'customer'
        },
        // Optional: Profile picture URL, phone number, addresses (can be separate table)
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'users',
        hooks: {
            // TODO: Add hooks for hashing password BEFORE saving (see authUtils)
            // beforeCreate: async (user) => { ... },
            // beforeUpdate: async (user) => { ... }
        }
    });

    // Associations defined in index.js
    // User.associate = (models) => {
    //     User.hasMany(models.Order, { foreignKey: 'customerId', as: 'orders' });
    //     User.hasOne(models.Seller, { foreignKey: 'userId', as: 'seller' });
    //     User.hasMany(models.Review, { foreignKey: 'customerId', as: 'reviews' });
    // };

    return User;
};
```

```
code/backend/src/routes/adminRoutes.js
```
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const { protect, requireRole } = require('../middleware/authMiddleware');

// All admin routes should be protected and require the 'admin' role
router.use(protect);
router.use(requireRole('admin'));

// User Management
router.get('/users', adminController.getAllUsers);
router.get('/users/:userId', adminController.getUserById);
router.put('/users/:userId', adminController.updateUser);
router.delete('/users/:userId', adminController.deleteUser);

// Product Management (Moderation, Deletion)
router.get('/products', adminController.getAllProducts);
router.get('/products/:productId', adminController.getProductById);
router.put('/products/:productId', adminController.moderateProduct); // Endpoint to change status/isActive
router.delete('/products/:productId', adminController.deleteProduct);

// Order Management
router.get('/orders', adminController.getAllOrders);
router.get('/orders/:orderId', adminController.getOrderById);
router.put('/orders/:orderId/status', adminController.updateOrderStatus); // Endpoint to change order status

// Category Management (TODO: Implement controllers)
// router.get('/categories', adminController.getAllCategories);
// router.post('/categories', adminController.createCategory);
// router.put('/categories/:categoryId', adminController.updateCategory);
// router.delete('/categories/:categoryId', adminController.deleteCategory);

module.exports = router;
```

```
code/backend/src/routes/authRoutes.js
```
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

router.post('/register', authController.registerUser);
router.post('/login', authController.loginUser);

// TODO: Add password reset routes

module.exports = router;
```

```
code/backend/src/routes/index.js
```
const express = require('express');
const router = express.Router();

// Import individual route modules
const authRoutes = require('./authRoutes');
const userRoutes = require('./userRoutes');
const productRoutes = require('./productRoutes');
const orderRoutes = require('./orderRoutes');
const reviewRoutes = require('./reviewRoutes');
const adminRoutes = require('./adminRoutes');

// Mount routes
router.use('/auth', authRoutes);
router.use('/users', userRoutes); // User specific actions (profile)
router.use('/products', productRoutes);
router.use('/orders', orderRoutes); // Customer and Seller order views/updates
router.use('/reviews', reviewRoutes);
router.use('/admin', adminRoutes); // Admin panel routes

module.exports = router;
```

```
code/backend/src/routes/orderRoutes.js
```
const express = require('express');
const router = express.Router();
const orderController = require('../controllers/orderController');
const { protect, requireRole } = require('../middleware/authMiddleware');

// Protect all order routes
router.use(protect);

// Customer routes
router.post('/', requireRole('customer'), orderController.createOrder); // Create a new order from cart
router.get('/me', requireRole('customer'), orderController.getCustomerOrders); // Get orders for the logged-in customer

// Seller routes
router.get('/seller', requireRole('seller'), orderController.getSellerOrders); // Get orders for the logged-in seller

// Shared route (Customer/Seller/Admin can view details if authorized)
router.get('/:orderId', orderController.getOrderDetails);

// Update status (Typically by Seller or Admin)
router.put('/:orderId/status', requireRole(['seller', 'admin']), orderController.updateOrderStatus);


module.exports = router;
```

```
code/backend/src/routes/productRoutes.js
```
const express = require('express');
const router = express.Router();
const productController = require('../controllers/productController');
const { protect, requireRole } = require('../middleware/authMiddleware');
const multer = require('multer'); // For handling file uploads

// Configure multer for image uploads (example using memory storage)
// TODO: Configure actual storage (disk, S3) and file size/type limits
const upload = multer({ storage: multer.memoryStorage() });


// Public routes
router.get('/', productController.getProducts); // Get all products with filters/search
router.get('/:productId', productController.getProductById); // Get single product details
router.get('/categories', productController.getCategories); // Get all categories

// Seller routes (protected, requires seller role)
router.post('/', protect, requireRole('seller'), upload.array('images', 10), productController.createProduct); // Create new product with images
router.put('/:productId', protect, requireRole('seller'), upload.array('images', 10), productController.updateProduct); // Update product details and images
router.delete('/:productId', protect, requireRole('seller'), productController.deleteProduct); // Delete product

// TODO: Add route for getting products by a specific seller ID
// TODO: Add route for featured products
```

```
code/backend/src/routes/reviewRoutes.js
```
const express = require('express');
const router = express.Router({ mergeParams: true }); // mergeParams to access parent route params like :productId
const reviewController = require('../controllers/reviewController');
const { protect, requireRole } = require('../middleware/authMiddleware');

// Get reviews for a specific product (public)
router.get('/', reviewController.getReviewsForProduct);

// Create a review (protected, requires customer role)
router.post('/', protect, requireRole('customer'), reviewController.createReview);

// TODO: Add routes for updating and deleting reviews (protected, requires customer or admin role)

module.exports = router;
```

```
code/backend/src/routes/userRoutes.js
```
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const { protect } = require('../middleware/authMiddleware');

// Protect user profile routes
router.use(protect);

// Get logged-in user's profile
router.get('/me', userController.getUserProfile);

// Update logged-in user's profile
router.put('/me', userController.updateUserProfile);

// TODO: Add routes for managing addresses, wishlist, etc.
// TODO: Add seller specific profile routes (e.g., GET /api/v1/users/seller/me, PUT /api/v1/users/seller/me)
```

```
code/backend/src/services/adminService.js
```
const { User, Product, Order, Seller, Category, ProductImage, OrderItem } = require('../models'); // Import all necessary models

// User Management
exports.findAllUsers = async () => {
    // TODO: Implement filtering, sorting, pagination
    return User.findAll({
        attributes: ['id', 'email', 'name', 'role', 'createdAt', 'updatedAt'], // Exclude passwordHash
        include: { model: Seller, as: 'seller', attributes: ['id', 'shopName'] } // Include basic seller info
    });
};

exports.findUserById = async (userId) => {
    return User.findByPk(userId, {
         attributes: ['id', 'email', 'name', 'role', 'createdAt', 'updatedAt'], // Exclude passwordHash
         include: { model: Seller, as: 'seller', attributes: ['id', 'shopName', 'description', 'shopImage'] }
    });
};

exports.updateUser = async (userId, updateData) => {
    // TODO: Validate updateData - admins might update roles, but sensitive fields need care
    const user = await User.findByPk(userId);
    if (!user) {
        return null; // User not found
    }
    // Prevent changing password directly via this route unless specifically handled
    if (updateData.password) {
        // TODO: Hash new password before updating
        // updateData.passwordHash = await hashPassword(updateData.password);
        delete updateData.password; // Ensure raw password isn't saved
    }

    // Update user fields
    await user.update(updateData);

    // If role is changed to seller and no seller profile exists, create one (basic)
    if (updateData.role === 'seller' && !(await user.getSeller())) {
        // TODO: Ensure shopName is provided if creating a seller profile
        await Seller.create({ userId: user.id, shopName: `${user.name}'s Shop` }); // Placeholder shop name
    }
    // If role is changed from seller, consider deactivating/removing seller profile

    // Re-fetch the updated user with included seller info
    return this.findUserById(userId);
};

exports.deleteUser = async (userId) => {
    const user = await User.findByPk(userId);
    if (!user) {
        return false; // User not found
    }
    // TODO: Implement cascade deletion or soft delete for related data (products, orders, reviews)
    // For safety, often preferable to soft delete or mark as inactive.
    await user.destroy(); // Hard delete - use with caution!
    return true;
};

// Product Management
exports.findAllProducts = async () => {
     // TODO: Implement filtering (e.g., by moderationStatus), sorting, pagination
     return Product.findAll({
        include: [
             { model: Seller, as: 'seller', attributes: ['id', 'shopName'] },
             { model: Category, as: 'category', attributes: ['id', 'name'] },
             { model: ProductImage, as: 'images', attributes: ['id', 'imageUrl', 'order'], order: [['order', 'ASC']] }
        ]
     });
};

exports.findProductById = async (productId) => {
    return Product.findByPk(productId, {
         include: [
             { model: Seller, as: 'seller', attributes: ['id', 'shopName'] },
             { model: Category, as: 'category', attributes: ['id', 'name'] },
             { model: ProductImage, as: 'images', attributes: ['id', 'imageUrl', 'order'], order: [['order', 'ASC']] },
             { model: Review, as: 'reviews', attributes: ['id', 'rating', 'comment'], include: { model: User, as: 'customer', attributes: ['id', 'name'] } } // Include basic review data
        ]
    });
};


exports.moderateProduct = async (productId, updateData) => {
    const product = await Product.findByPk(productId);
    if (!product) {
        return null; // Product not found
    }

    // Allowed fields for admin moderation update
    const allowedFields = ['moderationStatus', 'isActive', 'categoryId', 'name', 'description', 'price', 'stock'];
    const updateFields = {};
    allowedFields.forEach(field => {
        if (updateData[field] !== undefined) { // Check if field exists in updateData
            updateFields[field] = updateData[field];
        }
    });

    if (Object.keys(updateFields).length === 0) {
         // No valid fields provided for update
         const error = new Error('No valid fields provided for product moderation update');
         error.status = 400;
         throw error;
    }

    await product.update(updateFields);

    // Re-fetch updated product with associations
    return this.findProductById(productId);
};

exports.deleteProduct = async (productId) => {
     const product = await Product.findByPk(productId);
    if (!product) {
        return false; // Product not found
    }
    // TODO: Handle related data (images, order items, reviews) - delete or handle relationships
    await product.destroy(); // Hard delete - use with caution!
    return true;
};

// Order Management
exports.findAllOrders = async () => {
     // TODO: Implement filtering, sorting, pagination
     return Order.findAll({
        include: [
             { model: User, as: 'customer', attributes: ['id', 'name', 'email'] },
             { model: OrderItem, as: 'items', include: { model: Product, as: 'product', attributes: ['id', 'name', 'sellerId'], include: { model: Seller, as: 'seller', attributes: ['id', 'shopName'] } } }
        ],
         order: [['orderDate', 'DESC']]
     });
};

exports.findOrderById = async (orderId) => {
    return Order.findByPk(orderId, {
         include: [
             { model: User, as: 'customer', attributes: ['id', 'name', 'email'] },
             { model: OrderItem, as: 'items', include: { model: Product, as: 'product', attributes: ['id', 'name', 'sellerId'], include: { model: Seller, as: 'seller', attributes: ['id', 'shopName'] } } }
         ]
    });
};

exports.updateOrderStatus = async (orderId, status, trackingNumber) => {
    const order = await Order.findByPk(orderId);
    if (!order) {
        return null; // Order not found
    }
    // TODO: Add validation for status transitions (e.g., cannot go from 'Shipped' back to 'Pending')
    await order.update({ status, trackingNumber });
     return order; // Return the updated order object
};

// TODO: Implement Category Management logic
```

```
code/backend/src/services/authService.js
```
const { User, Seller } = require('../models');
const { hashPassword, comparePasswords } = require('../utils/authUtils'); // Assuming these exist

exports.register = async (email, password, name, role, shopName) => {
    // Check if user already exists with this email
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
        const error = new Error('Email already exists');
        error.status = 409; // Conflict
        throw error;
    }

    // Hash the password
    const passwordHash = await hashPassword(password);

    // Create the user
    const newUser = await User.create({
        email,
        passwordHash,
        name,
        role
    });

    // If role is seller, create a corresponding seller entry
    if (role === 'seller') {
        // TODO: Validate shopName format, uniqueness if required at this stage
        await Seller.create({
            userId: newUser.id,
            shopName: shopName || `${name}'s Shop` // Use provided shop name or generate a default
        });
         // Re-fetch user including the new seller association for the response
         const userWithSeller = await User.findByPk(newUser.id, { include: { model: Seller, as: 'seller'} });
         return userWithSeller;

    }

    return newUser;
};

exports.login = async (email, password) => {
    // Find user by email
    const user = await User.findOne({ where: { email } });

    // If user not found or password doesn't match, return null
    if (!user || !(await comparePasswords(password, user.passwordHash))) {
        return null; // Indicate login failure
    }

    // Return the user object (excluding password hash)
    // Include seller info if the user is a seller
     if (user.role === 'seller') {
        return User.findByPk(user.id, { include: { model: Seller, as: 'seller'} });
     }


    return user;
};

exports.findUserById = async (id) => {
    // Find user by ID, excluding password hash
    return User.findByPk(id, {
        attributes: { exclude: ['passwordHash'] },
        include: { model: Seller, as: 'seller' } // Include seller if exists
    });
};


// TODO: Implement password reset logic (token generation, sending email, resetting password)
```

```
code/backend/src/services/orderService.js
```
const { Order, OrderItem, Product, User, Seller } = require('../models');
const { sequelize } = require('../models'); // Import sequelize instance for transactions

exports.createOrder = async (customerId, cartItems, shippingAddress) => {
    // Use a transaction to ensure atomicity (either all database operations succeed or none do)
    const transaction = await sequelize.transaction();
    try {
        let totalAmount = 0;
        const orderItemsData = [];

        // Validate items and calculate total amount within the transaction
        for (const item of cartItems) {
            const product = await Product.findByPk(item.productId, { transaction });

            // TODO: Add more robust validation: check if product exists, is active, and if enough stock is available
             if (!product || product.stock < item.quantity || product.moderationStatus !== 'Approved' || !product.isActive) {
                 // Rollback transaction and throw error if validation fails
                 await transaction.rollback();
                 const error = new Error(`Product ${item.productId} is not available in requested quantity or is inactive/unapproved.`);
                 error.status = 400;
                 throw error;
             }

            const itemPrice = parseFloat(product.price); // Ensure price is float
            totalAmount += itemPrice * item.quantity;

            orderItemsData.push({
                productId: item.productId,
                quantity: item.quantity,
                priceAtOrder: itemPrice // Store price at the time of order
            });

            // TODO: Decrease product stock
             await product.decrement('stock', { by: item.quantity, transaction });
        }

        // Create the order
        const order = await Order.create({
            customerId,
            shippingAddress,
            totalAmount: parseFloat(totalAmount.toFixed(2)), // Ensure correct decimal storage
            status: 'Pending', // Initial status
            paymentStatus: 'Pending' // Initial payment status (should be updated after successful payment)
        }, { transaction });

        // Create order items
        for (const itemData of orderItemsData) {
            await OrderItem.create({
                orderId: order.id,
                ...itemData
            }, { transaction });
        }

        // TODO: Integrate Payment Gateway processing here BEFORE committing the transaction
        // Process payment using a token from the frontend
        // const paymentSuccess = await paymentService.processPayment(totalAmount, paymentToken, transaction);
        // if (!paymentSuccess) {
        //     await transaction.rollback();
        //     const error = new Error('Payment failed');
        //     error.status = 400; // Or appropriate payment error status
        //     throw error;
        // }
        // await order.update({ paymentStatus: 'Paid' }, { transaction }); // Update payment status


        // Commit the transaction
        await transaction.commit();

        // TODO: Trigger email notification service (can be done outside the transaction, perhaps via a message queue)

        return order; // Return the created order object
    } catch (error) {
        // If any step failed, the transaction is automatically rolled back if `throw error` is used
        // or manually rolled back if catch block handles it
         if (transaction && !transaction.finished) {
              await transaction.rollback();
         }
        throw error; // Re-throw the error for the controller to handle
    }
};

exports.findOrdersByCustomerId = async (customerId) => {
    // Find orders for a specific customer
    return Order.findAll({
        where: { customerId },
        include: [
            {
                model: OrderItem,
                as: 'items',
                include: {
                     model: Product,
                     as: 'product',
                     attributes: ['id', 'name', 'price'], // Include basic product info
                     include: { model: ProductImage, as: 'images', attributes: ['imageUrl'], limit: 1 } // Include one image
                }
            }
        ],
        order: [['orderDate', 'DESC']] // Latest orders first
    });
};

exports.findOrdersBySellerId = async (sellerId) => {
    // Find order items that belong to products from a specific seller
    // Then group/structure them by order. This requires a slightly more complex query or post-processing.

    // A simple approach is to find OrderItems belonging to the seller's products and then include the Order details
    const orderItems = await OrderItem.findAll({
        include: [
            {
                model: Product,
                as: 'product',
                where: { sellerId: sellerId },
                attributes: ['id', 'name', 'price'],
                include: { model: ProductImage, as: 'images', attributes: ['imageUrl'], limit: 1 }
            },
            {
                model: Order,
                as: 'order',
                attributes: ['id', 'orderDate', 'status', 'shippingAddress', 'paymentStatus', 'totalAmount', 'trackingNumber'],
                include: { model: User, as: 'customer', attributes: ['id', 'name', 'email'] } // Include customer info
            }
        ],
        order: [['orderId', 'DESC'], ['createdAt', 'ASC']] // Order by Order, then item creation
    });

    // TODO: Post-process orderItems to group them by Order for a cleaner response structure
    // This is more complex than a simple query. For V1, returning items might suffice or implement grouping here.
    // Example grouping structure: [{ order: { id, status, ... }, items: [{ item1 }, { item2 }] }]

    // Simple return of items for now:
    return orderItems;
};

exports.findOrderById = async (orderId) => {
     // Find a specific order by ID, including items and related product/customer/seller info
    return Order.findByPk(orderId, {
        include: [
            { model: User, as: 'customer', attributes: ['id', 'name', 'email'] },
             {
                model: OrderItem,
                as: 'items',
                include: {
                    model: Product,
                    as: 'product',
                    attributes: ['id', 'name', 'price'],
                    include: [
                         { model: Seller, as: 'seller', attributes: ['id', 'shopName'] },
                         { model: ProductImage, as: 'images', attributes: ['imageUrl'], limit: 1 }
                    ]
                 }
            }
        ]
    });
};


exports.updateOrderStatus = async (orderId, status, trackingNumber, sellerId, userRole) => {
    const order = await this.findOrderById(orderId); // Fetch order with items

    if (!order) {
        return null; // Order not found
    }

    // Authorization Check:
    // Admin can update any order status.
    // Seller can update status ONLY if the order contains items from their shop.
    const isSellerInvolved = userRole === 'seller' && order.items.some(item => item.product.sellerId === sellerId);
    const isAdmin = userRole === 'admin';

    if (!isAdmin && !isSellerInvolved) {
        return null; // Unauthorized
    }

    // TODO: Add validation for status transitions based on business logic
    // e.g., only 'Pending' -> 'Processing', 'Processing' -> 'Shipped' are valid transitions by seller/admin.
    // User might mark 'Shipped' -> 'Delivered'.

    const validStatuses = ['Pending', 'Processing', 'Shipped', 'Delivered', 'Cancelled'];
    if (!validStatuses.includes(status)) {
         const error = new Error(`Invalid status provided: ${status}`);
         error.status = 400;
         throw error;
    }

     // Update the order status and tracking number
    await order.update({ status, trackingNumber: trackingNumber || order.trackingNumber }); // Only update tracking if provided

    // Re-fetch the updated order
    return this.findOrderById(orderId);
};

// TODO: Implement function to check if a customer has purchased a specific product for review validation
// exports.hasCustomerPurchasedProduct = async (customerId, productId) => { ... }
```

```
code/backend/src/services/paymentService.js
```
// This service interacts with the external payment gateway API (e.g., Stripe, PayPal)
// It should NEVER store sensitive payment information like credit card numbers.
// Integration typically involves client-side SDKs to tokenize card details,
// and then sending that token to the backend to perform the charge via the gateway's API.

const config = require('../config/config');
// const stripe = require('stripe')(config.stripe.secretKey); // Example Stripe integration

exports.processPayment = async (amount, paymentMethodId /*, transaction */) => {
    // This is a simplified placeholder. Real integration is more complex.
    console.log(`[Payment Service] Attempting to process payment of ${amount} with method ID ${paymentMethodId}`);

    try {
        // Example using Stripe (conceptual):
        // const paymentIntent = await stripe.paymentIntents.create({
        //     amount: Math.round(amount * 100), // Amount in cents
        //     currency: 'usd', // Or your platform's currency
        //     payment_method: paymentMethodId,
        //     confirm: true, // Confirm the payment immediately
        //     // Add metadata like order ID, customer ID
        //     metadata: { integration_payload: 'manual' },
        //     // Optional: Add a database transaction if the payment gateway library supports it,
        //     // or ensure your error handling correctly rolls back DB changes if payment fails.
        //     // stripeAccount: '{{CONNECTED_ACCOUNT_ID}}', // If using Stripe Connect for sellers
        // }, {
        //     // idempotencyKey: order.id, // Prevent duplicate charges for the same order
        //     // stripeAccount: '{{SELLER_STRIPE_ACCOUNT_ID}}' // If direct charging seller
        // });

        // Based on paymentIntent.status, determine success/failure
        // if (paymentIntent.status === 'succeeded') {
        //     console.log('[Payment Service] Payment successful:', paymentIntent.id);
        //     return { success: true, status: 'Paid', transactionId: paymentIntent.id };
        // } else {
        //     // Handle other statuses like 'requires_action', 'requires_capture', etc.
        //      console.warn('[Payment Service] Payment did not succeed immediately:', paymentIntent.status);
        //      // Depending on the gateway flow, you might return different statuses
        //     return { success: false, status: paymentIntent.status, error: 'Payment requires further action or failed' };
        // }

        // --- Placeholder Simulation ---
        console.log("[Payment Service] Simulating successful payment...");
         await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate delay
        console.log("[Payment Service] Payment simulation complete.");
        return { success: true, status: 'Paid', transactionId: 'simulated_txn_' + Date.now() };


    } catch (error) {
        console.error('[Payment Service] Payment processing failed:', error.message);
         // Log full error details server-side
        return { success: false, status: 'Failed', error: error.message };
    }
};

// TODO: Implement refund functionality
// exports.processRefund = async (transactionId, amount) => { ... }

// TODO: Implement webhook handler endpoint for payment gateway notifications (e.g., charge.succeeded, charge.failed)
// This is crucial for handling asynchronous payment outcomes.
```

```
code/backend/src/services/productService.js
```
const { Product, Seller, Category, ProductImage, Review, User } = require('../models');
const { Op } = require('sequelize'); // For search/filtering operations
// const fileStorageService = require('./fileStorageService'); // Assume a service for file uploads (S3, local etc.)

exports.findProducts = async ({ search, filters, sort, pagination }) => {
    const where = {
        moderationStatus: 'Approved', // Only return approved products by default for public view
        isActive: true // Only return active products
    };
    const order = [];
    const include = [
        { model: Seller, as: 'seller', attributes: ['id', 'shopName'] },
        { model: Category, as: 'category', attributes: ['id', 'name'] },
        { model: ProductImage, as: 'images', attributes: ['id', 'imageUrl', 'order'], order: [['order', 'ASC']], limit: 1 } // Fetch only the first image
    ];

    // Apply search filter
    if (search) {
        where[Op.or] = [
            { name: { [Op.iLike]: `%${search}%` } }, // Case-insensitive search on name
            { description: { [Op.iLike]: `%${search}%` } }, // Case-insensitive search on description
            // TODO: Search by seller name (requires joining Seller table)
        ];
    }

    // Apply other filters
    if (filters.category) {
        // Find the category ID first, or include Category model and filter on name
        const category = await Category.findOne({ where: { name: filters.category } });
        if (category) {
            where.categoryId = category.id;
        } else {
            // If category not found, return no products
             return { products: [], totalCount: 0 };
        }
    }
    if (filters.minPrice) {
        where.price = { [Op.gte]: filters.minPrice };
    }
    if (filters.maxPrice) {
        where.price = { ...(where.price || {}), [Op.lte]: filters.maxPrice };
    }

    // Apply sorting
    switch (sort.by) {
        case 'price':
            order.push(['price', sort.order === 'desc' ? 'DESC' : 'ASC']);
            break;
        case 'name':
            order.push(['name', sort.order === 'desc' ? 'DESC' : 'ASC']);
            break;
        case 'createdAt':
            order.push(['createdAt', sort.order === 'desc' ? 'DESC' : 'ASC']);
            break;
        // TODO: Add sorting by rating (requires joining Reviews and calculating average)
        default:
            order.push(['createdAt', 'DESC']); // Default sort
            break;
    }

    // Apply pagination
    const offset = (pagination.page - 1) * pagination.limit;

    const { count, rows } = await Product.findAndCountAll({
        where,
        include,
        order,
        limit: pagination.limit,
        offset: offset
    });

    // TODO: Fetch average rating and review count for each product separately if needed here
    // This can be done with subqueries or separate queries for performance

    return {
        products: rows,
        totalCount: count
    };
};

exports.findProductById = async (productId) => {
    // Find a single product by ID, including all details
    return Product.findByPk(productId, {
        include: [
            { model: Seller, as: 'seller', attributes: ['id', 'shopName', 'description', 'shopImage'] },
            { model: Category, as: 'category', attributes: ['id', 'name'] },
            { model: ProductImage, as: 'images', attributes: ['id', 'imageUrl', 'order'], order: [['order', 'ASC']] },
            {
                model: Review,
                as: 'reviews',
                attributes: ['id', 'rating', 'comment', 'reviewDate'],
                include: { model: User, as: 'customer', attributes: ['id', 'name'] }, // Include reviewer's name
                order: [['reviewDate', 'DESC']]
            }
        ]
    });
};

exports.createProduct = async (sellerId, productData, images) => {
     // TODO: Add validation for productData fields
    const { name, description, price, stock, categoryId /*, variations */ } = productData;

    // Create the product (initially pending moderation)
    const newProduct = await Product.create({
        sellerId,
        categoryId,
        name,
        description,
        price: parseFloat(price),
        stock: parseInt(stock, 10),
        moderationStatus: 'Pending', // Requires admin approval
        isActive: false // Not active until approved by admin
        // variations: variations || null
    });

    // Handle image uploads
    if (images && images.length > 0) {
        // TODO: Call file storage service to upload images (e.g., to S3)
        // const uploadedImageUrls = await fileStorageService.uploadProductImages(images, newProduct.id);

        // Example placeholder: Simulate image URLs
        const uploadedImageUrls = images.map((file, index) => ({
            imageUrl: `https://placeholder.com/images/${newProduct.id}/${index}_${file.originalname}`, // Simulated URL
            order: index,
            productId: newProduct.id
        }));

        // Create ProductImage entries in the database
        await ProductImage.bulkCreate(uploadedImageUrls);
    }

    // Re-fetch the product with associations to return
    return this.findProductById(newProduct.id);
};

exports.updateProduct = async (productId, sellerId, productData, images) => {
    const product = await Product.findOne({ where: { id: productId, sellerId: sellerId } });

    if (!product) {
        return null; // Product not found or doesn't belong to this seller
    }

    // TODO: Add validation for productData fields
    // Allowed fields for sellers to update (excluding moderationStatus, isActive directly)
     const allowedFields = ['categoryId', 'name', 'description', 'price', 'stock' /*, 'variations' */];
     const updateFields = {};
     allowedFields.forEach(field => {
        if (productData[field] !== undefined) {
            updateFields[field] = productData[field];
        }
    });

    // If seller updates core details (name, description, category, price),
    // potentially reset moderation status to 'Pending' for re-approval
    // This depends on business rules. For now, let's allow updates without re-moderation for simplicity in V1.

    if (Object.keys(updateFields).length > 0) {
        // Ensure price and stock are numbers
         if (updateFields.price !== undefined) updateFields.price = parseFloat(updateFields.price);
         if (updateFields.stock !== undefined) updateFields.stock = parseInt(updateFields.stock, 10);

        await product.update(updateFields);
    }

    // Handle image updates
    if (images && images.length > 0) {
        // TODO: Option 1: Delete existing images and upload new ones (simpler)
        // await ProductImage.destroy({ where: { productId: product.id } });
        // const uploadedImageUrls = await fileStorageService.uploadProductImages(images, product.id);
        // await ProductImage.bulkCreate(uploadedImageUrls);

        // Option 2: More complex logic to add/remove/update specific images based on frontend data

         // Placeholder: Simulate image uploads and add them
        const existingImageCount = await ProductImage.count({ where: { productId: product.id } });
        const newImagesData = images.map((file, index) => ({
            imageUrl: `https://placeholder.com/images/${product.id}/new_${existingImageCount + index}_${file.originalname}`, // Simulated URL
            order: existingImageCount + index, // Append to existing order
            productId: product.id
        }));
        await ProductImage.bulkCreate(newImagesData);
    }
    // TODO: Add logic to delete specific images if requested (e.g., via image IDs in productData)


    // Re-fetch the updated product with associations
    return this.findProductById(product.id);
};

exports.deleteProduct = async (productId, sellerId) => {
     const product = await Product.findOne({ where: { id: productId, sellerId: sellerId } });

    if (!product) {
        return false; // Product not found or doesn't belong to this seller
    }

    // TODO: Handle related data (images, order items, reviews).
    // For reviews, maybe mark as inactive instead of deleting. Order items should probably remain for historical data.
    // Delete associated images first
    await ProductImage.destroy({ where: { productId: product.id } });
    // TODO: Also delete images from file storage (S3 etc.)

    await product.destroy(); // Delete the product itself

    return true;
};

exports.findAllCategories = async () => {
    // Find all categories
    return Category.findAll({
        attributes: ['id', 'name', 'description'],
        order: [['name', 'ASC']]
    });
};

// TODO: Implement finding products by seller
// exports.findProductsBySellerId = async (sellerId) => { ... }

// TODO: Implement finding featured products
// exports.findFeaturedProducts = async () => { ... }
```

```
code/backend/src/services/reviewService.js
```
const { Review, Product, User } = require('../models');
const { sequelize } = require('../models'); // For potential transaction or aggregation

exports.findReviewsByProductId = async (productId) => {
    // Find all reviews for a specific product, including reviewer's name
    return Review.findAll({
        where: { productId },
        include: { model: User, as: 'customer', attributes: ['id', 'name'] },
        order: [['reviewDate', 'DESC']] // Latest reviews first
    });
};

exports.createReview = async (productId, customerId, rating, comment) => {
     // TODO: Validation: Check if customer has purchased the product (call OrderService)
     // const hasPurchased = await orderService.hasCustomerPurchasedProduct(customerId, productId);
     // if (!hasPurchased) {
     //      const error = new Error('You can only review products you have purchased');
     //      error.status = 403;
     //      throw error;
     // }

     // TODO: Validation: Prevent multiple reviews per purchase (requires tracking purchases/reviews)
     // A simple check:
     // const existingReview = await Review.findOne({ where: { productId, customerId } });
     // if (existingReview) {
     //      const error = new Error('Customer has already reviewed this product');
     //      error.status = 409; // Conflict
     //      throw error;
     // }


    // Create the new review
    const newReview = await Review.create({
        productId,
        customerId,
        rating: parseInt(rating, 10),
        comment: comment || null, // Allow null comment
        reviewDate: new Date()
    });

    // TODO: Update the product's average rating and review count
    // This can be done via a database trigger, a separate scheduled job,
    // or triggered here after the review is created.
    // Calculating it here synchronously:
    // const result = await Review.findAll({
    //      attributes: [
    //          [sequelize.fn('AVG', sequelize.col('rating')), 'avgRating'],
    //          [sequelize.fn('COUNT', sequelize.col('id')), 'reviewCount']
    //      ],
    //      where: { productId },
    //      group: ['productId'] // Group by product if calculating for multiple products
    // });
    // if (result && result[0]) {
    //      const avgRating = parseFloat(result[0].dataValues.avgRating).toFixed(1);
    //      const reviewCount = parseInt(result[0].dataValues.reviewCount, 10);
    //      await Product.update({ averageRating: avgRating, reviewCount: reviewCount }, { where: { id: productId } });
    // }


    return newReview;
};

// TODO: Implement updateReview
// exports.updateReview = async (reviewId, customerId, updateData) => { ... }

// TODO: Implement deleteReview
// exports.deleteReview = async (reviewId, userId, userRole) => { ... }
```

```
code/backend/src/services/userService.js
```
const { User, Seller } = require('../models');
// const { comparePasswords } = require('../utils/authUtils'); // If allowing password change here

exports.findUserById = async (userId) => {
    // Find user by ID, excluding password hash for safety
    return User.findByPk(userId, {
        attributes: { exclude: ['passwordHash'] },
        include: { model: Seller, as: 'seller' } // Include seller details if exists
    });
};

exports.updateUser = async (userId, updateData) => {
    const user = await User.findByPk(userId);
    if (!user) {
        return null; // User not found
    }

    // TODO: Implement input validation for updateData
    // TODO: Restrict fields that can be updated by the user (e.g., prevent changing role, email without verification, password without old password)
    const allowedCustomerFields = ['name' /*, 'profilePictureUrl', 'phoneNumber' */];
    const allowedSellerFields = ['name' /*, 'profilePictureUrl', 'phoneNumber' */]; // Seller might update user details too
    const allowedAdminFields = ['name', 'role', 'email' /* etc. */]; // Admin can update more

    let allowedFields;
    switch (user.role) {
        case 'customer': allowedFields = allowedCustomerFields; break;
        case 'seller': allowedFields = allowedSellerFields; break;
        case 'admin': allowedFields = allowedAdminFields; break; // Assuming this service is only for the logged-in user updating *their* profile
        default: allowedFields = [];
    }

    const fieldsToUpdate = {};
    allowedFields.forEach(field => {
        if (updateData[field] !== undefined) {
            fieldsToUpdate[field] = updateData[field];
        }
    });

    // Handle password change separately if allowed
    // if (updateData.oldPassword && updateData.newPassword) {
    //      const isValidPassword = await comparePasswords(updateData.oldPassword, user.passwordHash);
    //      if (!isValidPassword) {
    //          const error = new Error('Invalid old password');
    //          error.status = 400;
    //          throw error;
    //      }
    //      fieldsToUpdate.passwordHash = await hashPassword(updateData.newPassword);
    //      // Remove password fields from updateData
    //      delete updateData.oldPassword;
    //      delete updateData.newPassword;
    // } else if (updateData.newPassword) {
    //      // Reject password change if old password is not provided
    //      const error = new Error('Old password is required to change password');
    //      error.status = 400;
    //      throw error;
    // }


    if (Object.keys(fieldsToUpdate).length === 0) {
        // No valid fields provided for update
         const error = new Error('No valid fields provided for profile update');
         error.status = 400;
         throw error;
    }


    await user.update(fieldsToUpdate);

    // If the user is a seller, they might also update their seller profile (shopName, description, etc.)
    // This might be handled by a separate endpoint/service or here depending on structure.
    // Example: Handle seller profile update if updateData contains seller-specific fields
    // if (user.role === 'seller' && updateData.seller) {
    //      const sellerProfile = await Seller.findOne({ where: { userId: user.id } });
    //      if (sellerProfile) {
    //          const allowedSellerProfileFields = ['shopName', 'description', 'shopImage'];
    //          const sellerFieldsToUpdate = {};
    //          allowedSellerProfileFields.forEach(field => {
    //              if (updateData.seller[field] !== undefined) {
    //                  sellerFieldsToUpdate[field] = updateData.seller[field];
    //              }
    //          });
    //          if (Object.keys(sellerFieldsToUpdate).length > 0) {
    //              await sellerProfile.update(sellerFieldsToUpdate);
    //          }
    //      }
    // }


    // Re-fetch the updated user with included seller info
    return this.findUserById(user.id);
};

exports.findSellerProfileByUserId = async (userId) => {
     return Seller.findOne({ where: { userId } });
};


// TODO: Implement logic for managing user addresses (separate table likely)
// TODO: Implement logic for managing user wishlist (separate table likely)
```

```
code/backend/src/utils/authUtils.js
```
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const config = require('../config/config');

const saltRounds = 10; // Cost factor for hashing

exports.hashPassword = async (password) => {
    try {
        const hash = await bcrypt.hash(password, saltRounds);
        return hash;
    } catch (error) {
        console.error('Error hashing password:', error);
        throw new Error('Error hashing password');
    }
};

exports.comparePasswords = async (password, hash) => {
    try {
        const match = await bcrypt.compare(password, hash);
        return match;
    } catch (error) {
        console.error('Error comparing passwords:', error);
         throw new Error('Error comparing passwords');
    }
};

exports.generateToken = (userId, userRole) => {
    const payload = {
        id: userId,
        role: userRole
        // Add other non-sensitive data to payload if needed (e.g., email, name - use sparingly)
    };

    const token = jwt.sign(
        payload,
        config.jwt.secret,
        { expiresIn: config.jwt.expiresIn }
    );

    return token;
};

exports.verifyToken = (token) => {
    try {
        const decoded = jwt.verify(token, config.jwt.secret);
        return decoded; // Contains payload (id, role)
    } catch (error) {
        console.error('Token verification failed:', error.message);
        return null; // Invalid token
    }
};
```

```
code/backend/src/utils/errorHandler.js
```
// Basic Error Handling Middleware
const errorHandler = (err, req, res, next) => {
    console.error(err.stack); // Log the error stack in development

    const status = err.status || 500; // Use error status or default to 500
    const message = err.message || 'Something went wrong'; // Use error message or generic message

    // Send error response
    res.status(status).json({
        message: message,
        // Include stack trace in development for debugging
        stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
};

module.exports = errorHandler;
```

```
code/public/index.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handmade Crafts E-commerce</title>
    <link rel="stylesheet" href="%PUBLIC_URL%/styles/main.css">
</head>
<body>
    <div id="root">
        <!-- Your React/App will be mounted here -->
    </div>
    <script src="%PUBLIC_URL%/index.js"></script>
</body>
</html>
```

```
code/src/App.js
```
import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'; // Using react-router-dom for navigation (example)

import Header from './components/Header';
import Footer from './components/Footer';
import HomePage from './pages/HomePage';
import ProductListPage from './pages/ProductListPage';
import ProductDetailPage from './pages/ProductDetailPage';
import ShoppingCartPage from './pages/ShoppingCartPage';
import CheckoutPage from './pages/CheckoutPage';
import DashboardPage from './pages/DashboardPage';
// TODO: Import other pages: Login, Register, Seller Shop, Admin Panel, Order Confirmation, etc.

import './styles/main.css'; // Import global styles

function App() {
    // TODO: Implement AuthProvider context to manage user login state
    // TODO: Implement CartProvider context to manage shopping cart state (initially client-side)

    return (
        <Router>
            {/* TODO: Wrap components in AuthProvider and CartProvider */}
            <div className="app-container">
                <Header />
                <main className="main-content">
                    <Switch>
                        <Route exact path="/" component={HomePage} />
                        <Route exact path="/products" component={ProductListPage} />
                        {/* Route with parameter for product ID */}
                        <Route path="/products/:productId" component={ProductDetailPage} />
                        <Route path="/cart" component={ShoppingCartPage} />
                        {/* TODO: Implement ProtectedRoute for checkout */}
                        <Route path="/checkout" component={CheckoutPage} />
                        {/* TODO: Implement ProtectedRoute and RoleBasedRoute for dashboard */}
                        <Route path="/dashboard" component={DashboardPage} />
                        {/* Add routes for Auth (Login/Register) */}
                        {/* Add routes for Seller Shop Page */}
                        {/* Add routes for Admin Panel (possibly separate app or routes) */}
                        {/* Add a 404 Not Found Page route */}

                         {/* Example Placeholder Routes */}
                         <Route path="/login" render={() => <div>Login Page</div>} />
                         <Route path="/register" render={() => <div>Register Page</div>} />
                         <Route path="/seller/:sellerId" render={() => <div>Seller Shop Page</div>} />
                         {/* <Route path="/admin" render={() => <div>Admin Dashboard (Separate App/Auth)</div>} /> */}
                         <Route path="/order-confirmation/:orderId" render={() => <div>Order Confirmation Page</div>} />


                    </Switch>
                </main>
                <Footer />
            </div>
             {/* TODO: Add Global Error/Notification System (e.g., toasts) */}
        </Router>
    );
}

export default App;

// TODO: Implement ProtectedRoute component to guard routes requiring authentication
// TODO: Implement RoleBasedRoute component to guard routes requiring specific roles (seller, admin)
```

```
code/src/index.js
```
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

// This is the entry point where the React application mounts to the DOM.
// It renders the main App component inside the div with id 'root' in index.html.
ReactDOM.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
    document.getElementById('root')
);

// Future work: Integrate state management (e.g., Redux, Context API, Zustand) - Cart and Auth are good candidates for Context
// Future work: Set up API client (e.g., Axios, Fetch) - Create a centralized api.js utility
// Future work: Add error boundary
```

```
code/src/components/Header.js
```
import React from 'react';
import { Link } from 'react-router-dom';
// TODO: Import AuthContext and CartContext

function Header() {
    // TODO: Use AuthContext to check if user is logged in and their role
    // TODO: Use CartContext to get item count in cart

    const isAuthenticated = false; // Placeholder
    const userRole = null; // Placeholder ('customer', 'seller', 'admin')
    const cartItemCount = 0; // Placeholder

    // Placeholder for responsive navigation
    // Needs search bar, site logo, nav links (Home, Products, Categories, About), user/account link, cart icon
    return (
        <header className="site-header">
            <div className="container">
                <div className="logo">
                    <Link to="/">Handmade Crafts</Link>
                </div>
                <nav className="main-nav">
                    <ul>
                        <li><Link to="/">Home</Link></li>
                        <li><Link to="/products">Shop All</Link></li>
                        {/* TODO: Add Categories dropdown/links (Fetch categories from API) */}
                         <li><Link to="/categories">Categories</Link></li>
                        {/* TODO: Add About/Contact links */}
                    </ul>
                </nav>
                <div className="user-actions">
                    {/* TODO: Implement Search Bar component */}
                     <div className="search-bar-placeholder">Search...</div>

                    {/* User/Account Link */}
                    {isAuthenticated ? (
                         <Link to="/dashboard" className="user-link">My Account</Link>
                    ) : (
                         <Link to="/login" className="user-link">Login/Register</Link>
                    )}


                    {/* Cart Icon */}
                    <Link to="/cart" className="cart-icon">
                        🛒 Cart
                        {cartItemCount > 0 && <span className="cart-count">{cartItemCount}</span>} {/* Display item count */}
                    </Link>
                </div>
            </div>
        </header>
    );
}

export default Header;

// TODO: Implement responsive design for header (e.g., hamburger menu on mobile)
// TODO: Implement Search Bar component and its functionality
// TODO: Fetch and display categories dynamically
// TODO: Connect with AuthContext to show/hide Login/Register or My Account links
// TODO: Connect with CartContext to display accurate item count
// TODO: Add basic styling for cart count badge
```

```
code/src/components/Footer.js
```
import React from 'react';
// TODO: Import Link from 'react-router-dom' if adding internal links

function Footer() {
    // Placeholder for site footer
    // Needs links (About Us, Contact, Terms, Privacy), social media links
    return (
        <footer className="site-footer">
            <div className="container">
                <p>&copy; 2023 Handmade Crafts E-commerce. All rights reserved.</p>
                {/* TODO: Add footer navigation links */}
                {/* TODO: Add social media links */}
                 <div className="footer-links">
                    {/* <Link to="/about">About Us</Link> | <Link to="/contact">Contact</Link> | ... */}
                    <a href="#">About Us</a> | <a href="#">Contact</a> | <a href="#">Terms</a> | <a href="#">Privacy</a>
                 </div>
                 <div className="social-links">
                    {/* <a href="#" aria-label="Facebook"><i className="fab fa-facebook-f"></i></a> */}
                     <a href="#" aria-label="Facebook">Facebook</a> | <a href="#" aria-label="Instagram">Instagram</a>
                 </div>
            </div>
        </footer>
    );
}

export default Footer;
```

```
code/src/components/ProductCard.js
```
import React from 'react';
import { Link } from 'react-router-dom';
// TODO: Import CartContext if "Add to Cart" button is here

function ProductCard({ product }) {
    // Represents a single product item in a grid/list view
    // Needs to display: Image, Name, Price, Seller Info, possibly Rating/Review count
    // Needs to be a link to the Product Detail Page
    // Example product structure should match backend API response:
    // { id, name, price, images: [{ imageUrl, order }, ...], seller: { shopName }, rating, reviewCount }
    const { id, name, price, images, seller, rating, reviewCount, stock, isActive, moderationStatus } = product; // Example product structure

    const imageUrl = (images && images.length > 0) ? images[0].imageUrl : 'placeholder.jpg';
    const sellerName = seller ? seller.shopName : 'Unknown Seller';
    const displayPrice = typeof price === 'number' ? price.toFixed(2) : (typeof price === 'string' ? parseFloat(price).toFixed(2) : 'N/A');

     // TODO: Use CartContext or a handler passed from parent for "Add to Cart" logic
     const handleAddToCart = () => {
         console.log(`Adding product ${id} to cart`);
         // TODO: Call context function or handler
     };

     const isOutOfStock = stock <= 0;
     const isApprovedAndActive = moderationStatus === 'Approved' && isActive;
     // For a public product list, we should ideally only fetch approved & active products,
     // but checking here provides a safeguard for rendering.
     // For a seller's product list, they should see inactive/pending items.

    return (
        // TODO: Apply conditional class for styling based on status (e.g., out-of-stock)
        <div className={`product-card ${isOutOfStock ? 'out-of-stock-card' : ''}`}>
            <Link to={`/products/${id}`}>
                {/* TODO: Implement responsive image handling (srcset, sizes) */}
                <img src={imageUrl} alt={name} className="product-image" loading="lazy" />
                <h3 className="product-name">{name}</h3>
                <p className="product-price">${displayPrice}</p>
                <p className="seller-info">by {sellerName}</p>
                 {/* TODO: Display rating if available */}
                 {reviewCount > 0 && (
                    <p className="product-rating">★ {parseFloat(rating).toFixed(1)} ({reviewCount})</p>
                 )}
                 {/* Optional status badges for seller dashboard view */}
                 {/* {!isApprovedAndActive && (
                     <span className="status-badge">{moderationStatus}</span>
                 )} */}
            </Link>
            {/* TODO: Add to Cart button - maybe only show if product is approved, active, and in stock */}
            {isApprovedAndActive && !isOutOfStock && (
                 <button className="add-to-cart-button-small" onClick={handleAddToCart}>Add to Cart</button>
            )}
            {isOutOfStock && (
                 <p className="out-of-stock-message">Out of Stock</p>
            )}
        </div>
    );
}

export default ProductCard;

// TODO: Implement responsive styling for grid/list view
// TODO: Handle missing image gracefully (placeholder or error icon)
// TODO: Connect "Add to Cart" button with state management (CartContext)
// TODO: Display rating/review average and count fetched from backend
// TODO: Add visual indication for out-of-stock products
// TODO: Consider different rendering/actions based on user role (seller can edit/delete)
```

```
code/src/components/CartItem.js
```
import React from 'react';
import { Link } from 'react-router-dom';
// TODO: Import CartContext actions (removeItem, updateQuantity)

function CartItem({ item /*, onQuantityChange, onRemove */ }) {
    // Represents a single item in the shopping cart list
    // Needs to display: Product Image, Name, Price, Quantity input, Subtotal for item, Remove button
    // Example item structure: { id, product: { id, name, price, images: [{ imageUrl, order }] }, quantity }
    const { id, product, quantity } = item;
    const { id: productId, name, price, images } = product;

    const imageUrl = (images && images.length > 0) ? images[0].imageUrl : 'placeholder.jpg';
    const itemSubtotal = (parseFloat(price) * quantity).toFixed(2);

    // TODO: Use CartContext actions instead of props
    // const handleQuantityChange = (e) => {
    //     const newQuantity = parseInt(e.target.value, 10);
    //     // TODO: Add validation (min 1, max stock)
    //     if (!isNaN(newQuantity) && newQuantity >= 1) {
    //         // onQuantityChange(id, newQuantity); // Use item.id or product.id? Depends on cart structure
    //         updateQuantity(item.id, newQuantity); // Example using item ID from context
    //     }
    // };

    // const handleRemove = () => {
    //     // onRemove(id); // Use item.id or product.id?
    //      removeItem(item.id); // Example using item ID from context
    // };

     // Placeholder handlers using console.log
     const handleQuantityChange = (e) => {
        const newQuantity = parseInt(e.target.value, 10);
        if (!isNaN(newQuantity) && newQuantity >= 1) {
            console.log(`Placeholder: Update quantity for item ${id} to ${newQuantity}`);
             // TODO: Call actual context/prop function updateQuantity(id, newQuantity);
        }
     };

     const handleRemove = () => {
        console.log(`Placeholder: Remove item ${id}`);
        // TODO: Call actual context/prop function removeItem(id);
     };


    return (
        <div className="cart-item">
            <Link to={`/products/${productId}`}>
                 <img src={imageUrl} alt={name} className="item-image" />
            </Link>
            <div className="item-details">
                <Link to={`/products/${productId}`}>
                    <h3>{name}</h3>
                </Link>
                <p>Price: ${parseFloat(price).toFixed(2)}</p>
                <div className="quantity-control">
                    <label htmlFor={`quantity-${id}`}>Quantity:</label>
                    <input
                        id={`quantity-${id}`}
                        type="number"
                        min="1"
                        // TODO: Set max based on product stock
                        value={quantity}
                        onChange={handleQuantityChange}
                    />
                </div>
                <p>Subtotal: <strong>${itemSubtotal}</strong></p> {/* Use calculated subtotal */}
                <button onClick={handleRemove} className="remove-button">Remove</button>
            </div>
        </div>
    );
}

export default CartItem;

// TODO: Implement proper styling
// TODO: Connect with state management for cart updates (useContext or props from parent connected to state)
// TODO: Handle stock limits for quantity input
// TODO: Link product image/name to the product detail page
```

```
code/src/components/CheckoutForm.js
```
import React, { useState } from 'react';
// TODO: Import AuthContext to pre-fill user info
// TODO: Import Payment Gateway SDK elements (e.g., from @stripe/react-stripe-js)

function CheckoutForm({ onSubmit }) {
    // Placeholder component for checkout form
    // Needs fields for Shipping Address, Payment Information, potentially Billing Address
    // Needs validation
    // Needs to handle submission to the backend API

    // TODO: Get user info from AuthContext to pre-fill form
    // const { user } = useAuth();

    const [formData, setFormData] = useState({
        // Pre-fill from user if available
        // name: user?.name || '',
        // email: user?.email || '',
        shippingAddress: {
            line1: '',
            line2: '', // Optional
            city: '',
            state: '',
            zip: '',
            country: '',
        },
        // billingAddress: { ... }, // Optional if different from shipping
        // payment details handled by gateway SDK, not stored in state
        // consentToTerms: false, // Example checkbox
    });

    const [isProcessing, setIsProcessing] = useState(false); // State for button loading

    const handleChange = (e) => {
        const { name, value, type, checked } = e.target;
        // Handle checkboxes
        if (type === 'checkbox') {
             setFormData(prev => ({ ...prev, [name]: checked }));
             return;
        }
        // Basic handling for nested state like address (recursive or specific paths)
        const nameParts = name.split('.');
        if (nameParts.length > 1 && nameParts[0] in formData) {
            setFormData(prev => ({
                ...prev,
                [nameParts[0]]: {
                    ...prev[nameParts[0]],
                    [nameParts[1]]: value
                }
            }));
        } else {
             setFormData(prev => ({ ...prev, [name]: value }));
        }
    };

    // TODO: Implement comprehensive client-side validation function
    const validateForm = () => {
         let isValid = true;
         // Example: check required fields
         if (!formData.shippingAddress.line1 || !formData.shippingAddress.city || !formData.shippingAddress.state || !formData.shippingAddress.zip || !formData.shippingAddress.country) {
             isValid = false;
             console.error("Validation Error: Shipping address fields are required.");
             // TODO: Display validation errors to the user
         }
         // TODO: Validate payment details (handled by gateway SDK's validation)
         return isValid;
    };


    const handleSubmit = async (e) => {
        e.preventDefault();

        if (!validateForm()) {
            return; // Stop if validation fails
        }

        setIsProcessing(true);

        try {
            // 1. Collect payment method details using Payment Gateway SDK (e.g., stripe.confirmCardPayment or stripe.createPaymentMethod)
            // This step interacts with the gateway directly from the frontend to get a token or confirm payment intent.
            // const paymentMethodResult = await stripe.createPaymentMethod({
            //     type: 'card',
            //     card: elements.getElement(CardElement), // Assuming CardElement from Stripe Elements
            //     billing_details: { name: formData.name, email: formData.email, address: formData.billingAddress || formData.shippingAddress }
            // });
            // if (paymentMethodResult.error) {
            //      console.error('Payment Method Error:', paymentMethodResult.error.message);
            //      // TODO: Display error to user
            //      setIsProcessing(false);
            //      return;
            // }
            // const paymentMethodId = paymentMethodResult.paymentMethod.id;

            // 2. Call the onSubmit prop with the form data and the payment method ID/token
            // The parent (CheckoutPage) will then call the backend API
             const submissionData = {
                 ...formData,
                 // paymentMethodId: paymentMethodId // Pass the token/ID from gateway SDK
                 paymentMethodId: 'mock_payment_method_id' // Placeholder
             };

            await onSubmit(submissionData); // onSubmit should handle API call and potential errors

        } catch (error) {
            console.error('Checkout Form Submission Error:', error);
            // TODO: Display error to user
        } finally {
            setIsProcessing(false);
        }
    };

    // TODO: Integrate with a Payment Gateway SDK (e.g., Stripe Elements, PayPal Button)
    // The payment fields (like card number, expiry, CVC) should be handled by the SDK elements,
    // NOT standard input fields, to avoid sensitive data touching your server directly before tokenization.

    return (
        <form className="checkout-form" onSubmit={handleSubmit} noValidate> {/* noValidate prevents default browser validation */}
            <h2>Shipping Information</h2>
             {/* TODO: Pre-fill fields if user is logged in */}
            {/* Example Address Fields */}
            <div className="form-group">
                <label htmlFor="shippingAddress.line1">Address Line 1 <span className="required">*</span></label>
                <input type="text" id="shippingAddress.line1" name="shippingAddress.line1" value={formData.shippingAddress.line1} onChange={handleChange} required />
                 {/* TODO: Add error message display area */}
            </div>
             <div className="form-group">
                <label htmlFor="shippingAddress.line2">Address Line 2 (Optional)</label>
                <input type="text" id="shippingAddress.line2" name="shippingAddress.line2" value={formData.shippingAddress.line2} onChange={handleChange} />
            </div>
             <div className="form-group">
                <label htmlFor="shippingAddress.city">City <span className="required">*</span></label>
                <input type="text" id="shippingAddress.city" name="shippingAddress.city" value={formData.shippingAddress.city} onChange={handleChange} required />
            </div>
             <div className="form-group">
                <label htmlFor="shippingAddress.state">State/Province <span className="required">*</span></label>
                <input type="text" id="shippingAddress.state" name="shippingAddress.state" value={formData.shippingAddress.state} onChange={handleChange} required />
            </div>
             <div className="form-group">
                <label htmlFor="shippingAddress.zip">Zip/Postal Code <span className="required">*</span></label>
                <input type="text" id="shippingAddress.zip" name="shippingAddress.zip" value={formData.shippingAddress.zip} onChange={handleChange} required />
            </div>
             <div className="form-group">
                <label htmlFor="shippingAddress.country">Country <span className="required">*</span></label>
                 <select id="shippingAddress.country" name="shippingAddress.country" value={formData.shippingAddress.country} onChange={handleChange} required>
                    <option value="">Select Country</option>
                    {/* TODO: Populate with a list of countries */}
                     <option value="US">United States</option>
                     <option value="CA">Canada</option>
                     {/* Add more countries */}
                 </select>
            </div>

            {/* TODO: Add checkbox/logic for "Billing address is same as shipping" */}

            <h2>Payment Information</h2>
            {/* This section will typically involve a Payment Gateway SDK (Stripe Elements, etc.) */}
            {/* Placeholder: */}
            <div className="form-group payment-elements-placeholder">
                 <label>Credit Card Details <span className="required">*</span></label>
                 {/* Example: <CardElement options={CARD_ELEMENT_OPTIONS} /> */}
                 <div style={{border: '1px dashed #ccc', padding: '20px', textAlign: 'center'}}>
                     Payment Gateway Card Element goes here (e.g., Stripe CardElement)
                 </div>
                 {/* TODO: Add payment element */}
            </div>

            {/* TODO: Add Terms and Conditions checkbox */}
             {/* <div className="form-group">
                <input type="checkbox" id="consentToTerms" name="consentToTerms" checked={formData.consentToTerms} onChange={handleChange} required />
                <label htmlFor="consentToTerms">I agree to the <a href="#">Terms and Conditions</a> <span className="required">*</span></label>
             </div> */}


            <button type="submit" className="submit-button" disabled={isProcessing}>
                {isProcessing ? 'Processing...' : 'Place Order'}
            </button>

             {/* TODO: Display form errors */}
        </form>
    );
}

export default CheckoutForm;

// TODO: Integrate with a payment gateway SDK (Stripe, PayPal, etc.) to securely collect payment info.
// TODO: Implement comprehensive client-side validation using a library (e.g., Yup, Zod) or manually.
// TODO: Handle different payment methods if applicable.
// TODO: Display form errors to the user effectively.
// TODO: Add loading state on submission and disable button.
// TODO: Pre-fill user info if available.
// TODO: Add terms and conditions checkbox.
```

```
code/src/pages/HomePage.js
```
import React, { useEffect, useState } from 'react';
// TODO: Import API utility
// TODO: Import ProductCard and CategoryCard components
// TODO: Import SearchBar component

function HomePage() {
    // This page will display featured items, categories, search bar, etc.
    // Needs to fetch data for featured products or categories from the backend API.

    const [featuredProducts, setFeaturedProducts] = useState([]);
    const [categories, setCategories] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchData = async () => {
             try {
                 // TODO: Fetch featured products
                 // const featuredProductsResponse = await API.get('/products/featured');
                 // setFeaturedProducts(featuredProductsResponse.data);

                 // TODO: Fetch categories
                 // const categoriesResponse = await API.get('/products/categories'); // Assuming endpoint /api/v1/products/categories
                 // setCategories(categoriesResponse.data);

                 // Placeholder data:
                 setFeaturedProducts([
                    { id: 1, name: 'Handmade Ceramic Mug', price: 25.00, images: [{imageUrl:'placeholder-mug.jpg'}], seller: { shopName: 'Clay Creations' } },
                    { id: 2, name: 'Knitted Wool Scarf', price: 45.50, images: [{imageUrl:'placeholder-scarf.jpg'}], seller: { shopName: 'Warm Knits' } },
                     { id: 3, name: 'Wooden Carving', price: 75.00, images: [{imageUrl:'placeholder-carving.jpg'}], seller: { shopName: 'Wood Works' } },
                 ]);
                 setCategories([
                     { id: 1, name: 'Pottery', description: 'Handmade ceramic goods' },
                     { id: 2, name: 'Textiles', description: 'Knitted, woven, and sewn items' },
                     { id: 3, name: 'Woodcraft', description: 'Carvings and wooden items' },
                 ]);

                 setLoading(false);

             } catch (err) {
                 setError(err);
                 setLoading(false);
             }
        };

        fetchData();
    }, []);

    if (loading) return <p className="loading-message">Loading...</p>;
    if (error) return <p className="error-message">Error loading data: {error.message}</p>;


    return (
        <div className="home-page container">
            <section className="hero-section">
                {/* TODO: Add hero image/banner and call to action */}
                <h1>Welcome to Handmade Crafts</h1>
                <p>Discover unique items crafted with passion.</p>
                 {/* TODO: Add a button to "Shop All" */}
            </section>


            <section className="search-section">
                 {/* TODO: Implement Search Bar component */}
                 <div className="search-bar-placeholder">
                     <input type="text" placeholder="Search for items..." />
                     <button>Search</button>
                 </div>
            </section>


            <section className="featured-products">
                <h2>Featured Items</h2>
                {/* TODO: Implement ProductCard component */}
                <div className="product-grid">
                    {featuredProducts.length > 0 ? (
                         featuredProducts.map(product => (
                            <div key={product.id} className="product-card-wrapper"> {/* Wrapper for grid item styling if needed */}
                                <ProductCard product={product} />
                             </div>
                        ))
                    ) : (
                         <p>No featured products found.</p>
                    )}
                </div>
            </section>

            <section className="categories">
                 <h2>Shop by Category</h2>
                 {/* TODO: Implement CategoryCard component or simple links */}
                 <div className="categories-list">
                    {categories.length > 0 ? (
                         categories.map(category => (
                             <Link key={category.id} to={`/products?category=${category.name}`} className="category-link-card">
                                 <h3>{category.name}</h3>
                                 {/* <p>{category.description}</p> */}
                             </Link>
                         ))
                    ) : (
                         <p>No categories found.</p>
                    )}
                 </div>
            </section>

            {/* Add other sections like "New Arrivals", "Popular Sellers", etc. */}
        </div>
    );
}

export default HomePage;

// TODO: Implement Search Bar component.
// TODO: Fetch and display actual featured products from backend API.
// TODO: Fetch and display categories from backend API.
// TODO: Implement responsive layout for featured products (using ProductCard) and categories sections.
// TODO: Add a Hero section.
// TODO: Create a simple CategoryCard component or style the links nicely.
```

```
code/src/pages/ProductListPage.js
```
import React, { useEffect, useState } from 'react';
import { useLocation, useHistory } from 'react-router-dom'; // To read/update URL query params
// TODO: Import API utility
import ProductCard from '../components/ProductCard';
// TODO: Import Filter and Sort components
// TODO: Import Pagination component

function ProductListPage() {
    // This page displays a list/grid of products, typically with search/filter/sort options.
    // Needs to fetch products based on potential query parameters (search term, category, filters).

    const location = useLocation(); // Gives access to query params
    const history = useHistory(); // Allows changing URL/navigation

    const [products, setProducts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [totalCount, setTotalCount] = useState(0); // For pagination
    // State for filters/sort pulled from URL or defaults
    const [filters, setFilters] = useState({}); // { category: 'Pottery', minPrice: 10 }
    const [sort, setSort] = useState({ by: 'createdAt', order: 'desc' }); // { by: 'price', order: 'asc' }
    const [pagination, setPagination] = useState({ page: 1, limit: 10 }); // { page: 1, limit: 10 }


    // Effect to parse URL query parameters on load and location change
    useEffect(() => {
        const queryParams = new URLSearchParams(location.search);
        const initialFilters = {};
        if (queryParams.get('category')) initialFilters.category = queryParams.get('category');
        if (queryParams.get('minPrice')) initialFilters.minPrice = parseFloat(queryParams.get('minPrice'));
        if (queryParams.get('maxPrice')) initialFilters.maxPrice = parseFloat(queryParams.get('maxPrice'));
        // Add other filters...

        const initialSortBy = queryParams.get('sortBy') || 'createdAt';
        const initialSortOrder = queryParams.get('order') || 'desc';

        const initialPage = parseInt(queryParams.get('page'), 10) || 1;
        const initialLimit = parseInt(queryParams.get('limit'), 10) || 10;


        setFilters(initialFilters);
        setSort({ by: initialSortBy, order: initialSortOrder });
        setPagination({ page: initialPage, limit: initialLimit });

         // Trigger data fetch after setting initial state
         // The fetch effect below depends on these states
    }, [location.search]); // Re-run effect if the query string changes


    // Effect to fetch products whenever filters, sort, or pagination change
    useEffect(() => {
        const fetchProducts = async () => {
            setLoading(true);
            setError(null);

            // Construct API query parameters from state
            const queryParams = {
                q: filters.search, // Assuming a search filter might exist
                category: filters.category,
                minPrice: filters.minPrice,
                maxPrice: filters.maxPrice,
                sortBy: sort.by,
                order: sort.order,
                page: pagination.page,
                limit: pagination.limit
            };

            // TODO: Remove undefined/null params
             Object.keys(queryParams).forEach(key =>
                (queryParams[key] === null || queryParams[key] === undefined || queryParams[key] === '') && delete queryParams[key]
            );


            try {
                // TODO: Fetch products from backend API
                // const response = await API.get('/products', { params: queryParams });
                // setProducts(response.data.products);
                // setTotalCount(response.data.totalCount);
                // setPagination({ ...pagination, totalPages: response.data.totalPages });

                 // Placeholder data based on category filter
                 const allPlaceholderProducts = [
                    { id: 1, name: 'Handmade Ceramic Mug', price: 25.00, images: [{imageUrl:'placeholder-mug.jpg'}], seller: { shopName: 'Clay Creations' }, moderationStatus: 'Approved', isActive: true, stock: 10 },
                    { id: 2, name: 'Knitted Wool Scarf', price: 45.50, images: [{imageUrl:'placeholder-scarf.jpg'}], seller: { shopName: 'Warm Knits' }, moderationStatus: 'Approved', isActive: true, stock: 5 },
                    { id: 3, name: 'Wooden Carving', price: 75.00, images: [{imageUrl:'placeholder-carving.jpg'}], seller: { shopName: 'Wood Works' }, moderationStatus: 'Approved', isActive: true, stock: 2 },
                    { id: 4, name: 'Beaded Necklace', price: 30.00, images: [{imageUrl:'placeholder-necklace.jpg'}], seller: { shopName: 'Gem Crafts' }, moderationStatus: 'Approved', isActive: true, stock: 20 },
                    { id: 5, name: 'Small Clay Pot', price: 15.00, images: [{imageUrl:'placeholder-pot.jpg'}], seller: { shopName: 'Clay Creations' }, moderationStatus: 'Approved', isActive: true, stock: 15 },
                    { id: 6, name: 'Woven Basket', price: 60.00, images: [{imageUrl:'placeholder-basket.jpg'}], seller: { shopName: 'Nature Weaves' }, moderationStatus: 'Approved', isActive: true, stock: 8 },
                 ];

                 let filteredProducts = allPlaceholderProducts;
                 if (filters.category) {
                     filteredProducts = filteredProducts.filter(p => {
                          // Simple case-insensitive match for placeholder
                         if (filters.category.toLowerCase() === 'pottery' && p.seller.shopName === 'Clay Creations') return true;
                         if (filters.category.toLowerCase() === 'textiles' && p.seller.shopName === 'Warm Knits') return true;
                         if (filters.category.toLowerCase() === 'woodcraft' && p.seller.shopName === 'Wood Works') return true;
                         return false; // No match
                     });
                 }
                 // TODO: Apply price filters, search filters, sorting, pagination to placeholder data

                 const start = (pagination.page - 1) * pagination.limit;
                 const end = start + pagination.limit;
                 const paginatedProducts = filteredProducts.slice(start, end);

                 setProducts(paginatedProducts);
                 setTotalCount(filteredProducts.length);
                 setPagination(prev => ({ ...prev, totalPages: Math.ceil(filteredProducts.length / pagination.limit) }));

                setLoading(false);

            } catch (err) {
                setError(err);
                setLoading(false);
            }
        };

        fetchProducts();

         // TODO: Update URL query parameters whenever filters, sort, or pagination state changes
         // This ensures the URL is shareable and reflects the current view.
         // Use history.push or history.replace
         // const searchParams = new URLSearchParams();
         // if (filters.category) searchParams.set('category', filters.category);
         // // Add other params...
         // searchParams.set('sortBy', sort.by);
         // searchParams.set('order', sort.order);
         // searchParams.set('page', pagination.page);
         // searchParams.set('limit', pagination.limit);
         // history.push({ search: searchParams.toString() });

    }, [filters, sort, pagination.page, pagination.limit]); // Depend on state that triggers fetching


    // Handlers for filter/sort/pagination changes - these update state which triggers useEffect
    const handleFilterChange = (newFilters) => {
         setFilters(prev => ({ ...prev, ...newFilters }));
         setPagination(prev => ({ ...prev, page: 1 })); // Reset to page 1 on filter change
    };

    const handleSortChange = (newSort) => {
        setSort(newSort);
         setPagination(prev => ({ ...prev, page: 1 })); // Reset to page 1 on sort change
    };

    const handlePageChange = (newPage) => {
        setPagination(prev => ({ ...prev, page: newPage }));
    };


    // if (loading) return <p>Loading products...</p>;
    if (error) return <p className="error-message">Error loading products: {error.message}</p>;

    return (
        <div className="product-list-page container">
            <h1>All Products</h1>

            <div className="filter-sort-section">
                {/* TODO: Implement Filter Component */}
                {/* Example: <FilterComponent currentFilters={filters} onFilterChange={handleFilterChange} /> */}
                 <div className="filter-placeholder">Filters: Category, Price Range, etc.</div>
                {/* TODO: Implement Sort Dropdown */}
                {/* Example: <SortDropdown currentSort={sort} onSortChange={handleSortChange} /> */}
                 <div className="sort-placeholder">Sort: Price, Name, Date</div>
            </div>

            {loading ? (
                 <p>Loading products...</p>
            ) : (
                products.length > 0 ? (
                    <div className="product-grid">
                        {products.map(product => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                ) : (
                     <p>No products found matching your criteria.</p>
                )
            )}


            {/* TODO: Implement Pagination Component */}
            {/* Example: <Pagination currentPage={pagination.page} totalPages={pagination.totalPages} onPageChange={handlePageChange} /> */}
             {!loading && products.length > 0 && (
                <div className="pagination-placeholder">
                    <p>Page {pagination.page} of {pagination.totalPages}</p>
                    {/* Add Prev/Next buttons */}
                </div>
             )}


            {/* TODO: Implement sticky filters/sorting on scroll (optional). */}
        </div>
    );
}

export default ProductListPage;

// TODO: Implement responsive grid/list view.
// TODO: Implement Filter component (by category, price range, etc.) using URL query parameters.
// TODO: Implement Sort functionality using URL query parameters.
// TODO: Fetch real data from backend API with query parameters.
// TODO: Implement Pagination component and hook it up to API calls.
// TODO: Update URL query parameters (history.push) when state changes to make the page shareable.
// TODO: Handle loading and error states gracefully.
```

```
code/src/pages/ProductDetailPage.js
```
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
// TODO: Import API utility
// TODO: Import CartContext or a handler for "Add to Cart"
// TODO: Import ReviewList and ReviewForm components
// TODO: Import AuthContext to determine if user can review

function ProductDetailPage() {
    // This page displays detailed information about a single product.
    // Needs to fetch product data based on the ID from the URL.
    // Needs sections for Description, Reviews, Seller Info.
    // Needs Add to Cart button.

    const { productId } = useParams(); // Get product ID from URL
    const [product, setProduct] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    // Reviews are fetched as part of the product detail payload from the backend

    // TODO: Get user info from AuthContext to check if they can leave a review
    // const { user, isAuthenticated } = useAuth();


    useEffect(() => {
        const fetchProduct = async () => {
            setLoading(true);
            setError(null);
            try {
                // TODO: Fetch product details from backend API
                // const response = await API.get(`/products/${productId}`);
                // setProduct(response.data);

                 // Placeholder data (matches backend model structure)
                 setProduct({
                     id: parseInt(productId, 10),
                     name: `Handmade Item #${productId}`,
                     description: `This is a detailed description for handmade item #${productId}. Crafted with care, using quality materials. Dimensions: approx. 10x10x5 cm. Weight: 200g. Note: As this is handmade, slight variations may occur.`,
                     price: 49.99,
                     stock: 10,
                     moderationStatus: 'Approved',
                     isActive: true,
                     images: [
                         { id: 1, imageUrl: `placeholder-large-${productId}_1.jpg`, order: 0 },
                         { id: 2, imageUrl: `placeholder-large-${productId}_2.jpg`, order: 1 },
                         { id: 3, imageUrl: `placeholder-large-${productId}_3.jpg`, order: 2 },
                     ],
                     seller: { id: 101, shopName: 'Artisan Works', description: 'Creating unique crafts since 2020.', shopImage: 'placeholder-seller-logo.jpg' },
                     category: { id: 1, name: 'Pottery' },
                     rating: 4.2, // Placeholder average rating
                     reviewCount: 5, // Placeholder review count
                     reviews: [ // Placeholder reviews included in product payload
                         { id: 101, rating: 5, comment: 'Absolutely beautiful!', reviewDate: '2023-10-26T10:00:00Z', customer: { id: 1, name: 'Alice' } },
                         { id: 102, rating: 4, comment: 'Very happy with the quality.', reviewDate: '2023-10-25T14:30:00Z', customer: { id: 2, name: 'Bob' } },
                     ]
                 });


                setLoading(false);
            } catch (err) {
                setError(err);
                setLoading(false);
            }
        };

        fetchProduct();

    }, [productId]); // Re-fetch if productId changes

    // TODO: Use CartContext or a handler passed from parent for "Add to Cart" logic
    const handleAddToCart = () => {
        console.log(`Adding product ${productId} to cart`);
        // TODO: Call CartContext add item function
        // addCartItem({ productId: product.id, quantity: 1, price: product.price, name: product.name, imageUrl: product.images[0]?.imageUrl }); // Example payload
    };

     // TODO: Implement logic to check if the logged-in user can write a review
     // Requires isAuthenticated, user.role === 'customer', and checking if they purchased this product
     const canWriteReview = false; // Placeholder logic

    if (loading) return <p>Loading product details...</p>;
    if (error) return <p className="error-message">Error loading product: {error.message}</p>;
    if (!product) return <p>Product not found.</p>; // Handle case where product is null after loading (e.g., 404 from API)

     const isOutOfStock = product.stock <= 0;
     const isApprovedAndActive = product.moderationStatus === 'Approved' && product.isActive;


    return (
        <div className="product-detail-page container">
             {!isApprovedAndActive && (
                  <div className="warning-banner">This product is currently not available for purchase. ({product.moderationStatus})</div>
             )}
            <div className="product-info">
                <div className="product-images">
                    {/* TODO: Implement Responsive Image Carousel/Gallery */}
                    {product.images && product.images.length > 0 ? (
                        <img src={product.images[0].imageUrl} alt={product.name} className="main-product-image" />
                         // TODO: Add thumbnail gallery below main image
                    ) : (
                         <img src="placeholder-large.jpg" alt="Placeholder" className="main-product-image" />
                    )}
                     {product.images && product.images.length > 1 && (
                         <div className="thumbnail-gallery-placeholder">Thumbnails here...</div>
                     )}
                </div>
                <div className="product-details">
                    <h1>{product.name}</h1>
                    <p className="price">${parseFloat(product.price).toFixed(2)}</p>
                    {/* Display rating and review count */}
                     <div className="product-rating-info">
                         {product.reviewCount > 0 ? (
                             <>
                                 <span className="rating">★ {parseFloat(product.rating).toFixed(1)} / 5</span>
                                 <span className="review-count"> ({product.reviewCount} reviews)</span>
                             </>
                         ) : (
                             <span className="no-reviews">No reviews yet.</span>
                         )}
                     </div>

                    {/* TODO: Implement Variations/Options Selection */}
                     {/* {product.variations && product.variations.length > 0 && (
                         <div className="product-variations-placeholder">Variations (e.g., Color, Size)</div>
                     )} */}


                    {/* Add to Cart Button */}
                    {isApprovedAndActive && !isOutOfStock && (
                         <button
                            className="add-to-cart-button"
                            onClick={handleAddToCart}
                            // disabled={isOutOfStock} // Also check if approved/active
                         >
                            Add to Cart
                        </button>
                    )}
                    {isOutOfStock && <p className="out-of-stock">Out of Stock</p>}
                     {!isApprovedAndActive && <p className="unavailable-message">Currently Unavailable</p>}


                    <section className="description">
                        <h2>Description</h2>
                        <p>{product.description}</p>
                    </section>

                    <section className="seller-info">
                        <h2>About the Seller</h2>
                        {product.seller ? (
                            <>
                                <p><strong>{product.seller.shopName}</strong></p>
                                <p>{product.seller.description}</p>
                                {/* TODO: Link to seller's shop page */}
                                 <Link to={`/seller/${product.seller.id}`}>View Shop</Link>
                            </>
                        ) : (
                            <p>Seller information not available.</p>
                        )}
                    </section>

                    <section className="reviews">
                        <h2>Customer Reviews ({product.reviewCount || 0})</h2>
                        {/* TODO: Implement ReviewList component */}
                        {/* Pass reviews data to ReviewList */}
                        {product.reviews && product.reviews.length > 0 ? (
                             <ul className="reviews-list">
                                 {product.reviews.map(review => (
                                    <li key={review.id} className="review-item">
                                        <p><strong>{review.customer?.name || 'Anonymous'}:</strong> ★ {review.rating}/5</p>
                                        {review.comment && <p>{review.comment}</p>}
                                        <p className="review-date">{new Date(review.reviewDate).toLocaleDateString()}</p>
                                    </li>
                                 ))}
                             </ul>
                        ) : (
                             <p>No reviews yet.</p>
                        )}


                        {/* TODO: Implement ReviewForm component */}
                         {canWriteReview && (
                             <div className="write-review-section">
                                 <h3>Write a Review</h3>
                                 {/* <ReviewForm productId={product.id} onSubmitSuccess={handleNewReview} /> */}
                                 <p>Placeholder for Review Form (Requires login and purchase verification)</p>
                             </div>
                         )}
                    </section>
                </div>
            </div>
        </div>
    );
}

export default ProductDetailPage;

// TODO: Implement responsive image gallery/carousel.
// TODO: Connect "Add to Cart" logic to CartContext.
// TODO: Implement variations selection logic (if product has them).
// TODO: Fetch real data from backend API including reviews and seller details.
// TODO: Add "Write a Review" component/functionality for eligible users (logged in, customer, purchased).
// TODO: Implement logic to update local state (reviews list, average rating) after a new review is successfully submitted.
// TODO: Handle loading and error states.
// TODO: Implement proper styling.
```

```
code/src/pages/ShoppingCartPage.js
```
import React, { useContext } from 'react';
// TODO: Import CartContext
import CartItem from '../components/CartItem';
import { Link } from 'react-router-dom';
// TODO: Import AuthContext to check if user is logged in before checkout

function ShoppingCartPage() {
    // This page displays items currently in the shopping cart.
    // Needs to get cart items from state management (Context, Redux, etc.).
    // Needs functionality to update quantity and remove items.
    // Needs to display subtotal and a button to proceed to checkout.

    // Example using Context:
    // const { cartItems, updateQuantity, removeItem } = useContext(CartContext);
    // const { isAuthenticated } = useContext(AuthContext);

     // Placeholder cart data:
     const cartItems = [
         { id: 1, product: { id: 1, name: 'Handmade Ceramic Mug', price: 25.00, images: [{imageUrl: 'placeholder-mug.jpg'}] }, quantity: 2 },
         { id: 2, product: { id: 2, name: 'Knitted Wool Scarf', price: 45.50, images: [{imageUrl: 'placeholder-scarf.jpg'}] }, quantity: 1 },
         { id: 3, product: { id: 3, name: 'Wooden Carving', price: 75.00, images: [{imageUrl: 'placeholder-carving.jpg'}] }, quantity: 1 },
     ];
     const updateQuantity = (itemId, quantity) => { console.log(`Placeholder: Update quantity for item ${itemId} to ${quantity}`); /* TODO: Implement state update */ };
     const removeItem = (itemId) => { console.log(`Placeholder: Remove item ${itemId}`); /* TODO: Implement state update */ };
     const isAuthenticated = true; // Placeholder


    const subtotal = cartItems.reduce((sum, item) => sum + parseFloat(item.product.price) * item.quantity, 0);

    // TODO: Add calculation for shipping and tax based on items and user's address (requires backend API call)
    const shippingCost = 0; // Placeholder
    const taxAmount = 0; // Placeholder
    const totalAmount = subtotal + shippingCost + taxAmount;


    return (
        <div className="shopping-cart-page container">
            <h1>Shopping Cart</h1>
            {cartItems.length === 0 ? (
                <div className="empty-cart">
                     <p>Your cart is empty.</p>
                     <Link to="/products" className="button">Start Shopping!</Link>
                </div>
            ) : (
                <div className="cart-content">
                    <div className="cart-items-list">
                        {cartItems.map(item => (
                            <CartItem
                                key={item.id} // Use a unique item id or product id + variations
                                item={item}
                                onQuantityChange={updateQuantity} // Pass handlers to CartItem
                                onRemove={removeItem}
                            />
                        ))}
                    </div>
                    <div className="cart-summary">
                        <h2>Order Summary</h2>
                        <div className="summary-details">
                             <p>Subtotal: <span>${subtotal.toFixed(2)}</span></p>
                             <p>Shipping: <span>${shippingCost.toFixed(2)}</span></p> {/* TODO: Calculate shipping */}
                             <p>Tax: <span>${taxAmount.toFixed(2)}</span></p> {/* TODO: Calculate tax */}
                             <p className="total">Total: <span>${totalAmount.toFixed(2)}</span></p>
                        </div>

                        {/* TODO: Implement checkout button logic */}
                        {isAuthenticated ? (
                             <Link to="/checkout" className="checkout-button">Proceed to Checkout</Link>
                        ) : (
                             <Link to="/login" className="checkout-button primary-button">Login to Checkout</Link>
                             // TODO: Maybe offer "Continue as Guest" option if supported
                        )}

                         {/* TODO: Add other options like "Continue Shopping" */}
                         <Link to="/products" className="continue-shopping-link">Continue Shopping</Link>
                    </div>
                </div>
            )}
        </div>
    );
}

export default ShoppingCartPage;

// TODO: Integrate with actual cart state management (Context, Redux, etc.).
// TODO: Implement updateQuantity and removeItem logic to modify the cart state.
// TODO: Calculate and display shipping costs and taxes (requires backend API based on items and destination).
// TODO: Implement responsive layout.
// TODO: Add clear path back to shopping.
// TODO: Integrate AuthContext to conditionally show checkout button or login prompt.
```

```
code/src/pages/CheckoutPage.js
```
import React, { useContext, useState, useEffect } from 'react';
import CheckoutForm from '../components/CheckoutForm';
// TODO: Import CartContext hook or context
// TODO: Import API utility
import { useHistory } from 'react-router-dom'; // Example for redirection
// TODO: Import AuthContext
// TODO: Import Payment Gateway Provider/Elements (e.g., from @stripe/react-stripe-js) - requires wrapping the component

function CheckoutPage() {
    // This page handles the checkout process.
    // Needs to display order summary and the checkout form.
    // Needs to send order data to the backend API for processing.

    // TODO: Get cart items and clear cart function from CartContext
    // const { cartItems, clearCart } = useCart();
    // TODO: Get isAuthenticated from AuthContext
    // const { isAuthenticated } = useAuth();

    const history = useHistory();

    // Placeholder cart items for summary
    const [cartItems, setCartItems] = useState([
        { id: 1, product: { id: 1, name: 'Handmade Ceramic Mug', price: 25.00 }, quantity: 2 },
        { id: 2, product: { id: 2, name: 'Knitted Wool Scarf', price: 45.50 }, quantity: 1 },
    ]);
     const isAuthenticated = true; // Placeholder
     const clearCart = () => { console.log('Placeholder: Cart Cleared'); setCartItems([]); }; // Placeholder

    useEffect(() => {
        // Redirect if cart is empty (unless it's loading)
        if (!isAuthenticated || (cartItems.length === 0 && !loading)) { // Assuming loading state might be added
            history.push('/cart'); // Redirect to cart if not authenticated or empty
        }
    }, [cartItems.length, isAuthenticated, history]); // Re-run if cart items count or auth state changes

     const subtotal = cartItems.reduce((sum, item) => sum + parseFloat(item.product.price) * item.quantity, 0);

     // TODO: Calculate shipping and tax based on items and form address input (requires backend API call)
     const shippingCost = 10.00; // Placeholder
     const taxRate = 0.05; // Placeholder 5%
     const taxAmount = subtotal * taxRate; // Simple tax calculation
     const totalAmount = subtotal + shippingCost + taxAmount;


    const handlePlaceOrder = async (formData) => {
        console.log('Order data submitted from form:', formData);

        // TODO: Add payment gateway integration here (e.g., confirm payment intent)
        // This might happen inside CheckoutForm or here before calling the API


        // Prepare order data for backend API
        const orderData = {
            cartItems: cartItems.map(item => ({
                productId: item.product.id,
                quantity: item.quantity,
                // priceAtOrder: item.product.price, // Backend should ideally fetch current price for validation
            })),
            shippingAddress: formData.shippingAddress,
            // Add billingAddress if different
            // Add paymentMethodId obtained from gateway SDK
            paymentMethodId: formData.paymentMethodId // Example placeholder
            // Add totalAmount calculated on backend side during validation
        };

        // Example API call (conceptual):
        // try {
        //     // TODO: Use actual API utility (e.g., await API.post('/orders', orderData);)
        //     console.log('Placeholder: Sending order data to backend...', orderData);
        //     await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate API call delay

        //     // Assuming backend returns order confirmation including orderId
        //     const mockOrderId = 'ORDER' + Date.now();
        //     console.log('Placeholder: Order placed successfully', mockOrderId);

        //     clearCart(); // Clear cart after successful order
        //     history.push(`/order-confirmation/${mockOrderId}`); // Redirect

        // } catch (error) {
        //     console.error('Error placing order:', error);
        //     // TODO: Display error message to user (e.g., using a notification system)
        //     alert(`Error placing order: ${error.message || 'An unexpected error occurred.'}`); // Simple alert
        // }

         // --- Placeholder Simulation ---
         console.log('Placeholder: Sending order data to backend...', orderData);
         await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate API call delay
         const mockOrderId = 'ORDER' + Date.now();
         console.log('Placeholder: Order placed successfully', mockOrderId);
         clearCart(); // Clear cart after successful order
         history.push(`/order-confirmation/${mockOrderId}`); // Redirect
         // --- End Placeholder ---
    };

    // Render nothing or a loading state if cart is empty initially or user is not authenticated (useEffect will redirect)
    if (cartItems.length === 0 || !isAuthenticated) {
         return <div className="checkout-page container">Redirecting to cart or login...</div>;
    }


    // TODO: Wrap the entire checkout form section in a Payment Gateway Provider (e.g., <Elements stripe={stripePromise}>)
    return (
        <div className="checkout-page container">
            <h1>Checkout</h1>

            <div className="checkout-flow">
                <div className="order-summary-sidebar">
                    <h2>Order Summary</h2>
                    <ul>
                        {cartItems.map(item => (
                            <li key={item.id}>
                                {item.product.name} x {item.quantity}
                                <span>${(parseFloat(item.product.price) * item.quantity).toFixed(2)}</span>
                            </li>
                        ))}
                    </ul>
                    <div className="summary-totals">
                         <p>Subtotal: <span>${subtotal.toFixed(2)}</span></p>
                         <p>Shipping: <span>${shippingCost.toFixed(2)}</span></p> {/* TODO: Calculate shipping */}
                         <p>Tax: <span>${taxAmount.toFixed(2)}</span></p> {/* TODO: Calculate tax */}
                         <p className="total">Total: <span>${totalAmount.toFixed(2)}</span></p>
                    </div>
                     {/* TODO: Add section for applying discounts/coupons if in scope */}
                </div>
                <div className="checkout-form-section">
                    {/* TODO: Implement multi-step checkout process with progress indicator. */}
                     <div className="progress-indicator-placeholder">Step 1 > Step 2 > Step 3</div>
                    {/* TODO: The CheckoutForm or a parent component needs to be wrapped with Payment Gateway Elements provider */}
                     <CheckoutForm onSubmit={handlePlaceOrder} />
                </div>
            </div>
        </div>
        // TODO: Add Payment Gateway Provider closing tag </Elements>
    );
}

export default CheckoutPage;

// TODO: Implement multi-step checkout process with progress indicator.
// TODO: Integrate Payment Gateway SDK for secure payment collection (requires wrapping relevant components).
// TODO: Implement client-side validation for the form (handled in CheckoutForm component).
// TODO: Connect with backend API to place the actual order.
// TODO: Handle shipping address and potentially billing address.
// TODO: Clear the cart state after a successful order.
// TODO: Redirect user to an order confirmation page.
// TODO: Handle errors during the checkout process and display them to the user.
// TODO: Implement responsive layout for summary and form.
// TODO: Ensure user is authenticated before allowing checkout (using AuthContext and useEffect redirect).
```

```
code/src/pages/DashboardPage.js
```
import React, { useContext, useState, useEffect } from 'react';
// TODO: Import AuthContext
// TODO: Import API utility
// TODO: Import components for different dashboard sections (OrderHistory, ProfileSettings, SellerProducts, SellerOrders, etc.)
import { Switch, Route, Link, useRouteMatch } from 'react-router-dom'; // For nested routes within dashboard

function DashboardPage() {
    // This page serves as a dashboard for logged-in users (Customer or Seller).
    // Needs conditional rendering based on user role.
    // Customer Dashboard: Order History, Profile Settings, Wishlist
    // Seller Dashboard: Shop Setup, Product Management, Order Management, Sales Reports
    // Admin Dashboard: User, Product, Order Management (often a separate app)

    // TODO: Use AuthContext to get user info and authentication status
    // const { user, loading: authLoading, isAuthenticated } = useContext(AuthContext);

    // Placeholder user data and loading state
     const [user, setUser] = useState(null); // { id: 1, name: 'John Doe', role: 'customer', sellerId: null }
     const [authLoading, setAuthLoading] = useState(true);
     const isAuthenticated = !!user; // Derived from user state

     useEffect(() => {
         // TODO: Fetch user data and check authentication state on component mount
         // This would ideally come from a global AuthContext or initial app load
         // Simulate fetching user data
         setTimeout(() => {
              // Example Customer User
              // setUser({ id: 1, name: 'Alice Customer', role: 'customer' });
              // Example Seller User
              setUser({ id: 2, name: 'Bob Seller', role: 'seller', sellerId: 101 });
             setAuthLoading(false);
         }, 500);
     }, []);


    const { path, url } = useRouteMatch(); // Get current path/url for nested routes

    if (authLoading) return <p>Loading dashboard...</p>;
    if (!isAuthenticated) {
        // Redirect to login or show login message - ProtectedRoute should handle this
        return <p>Please log in to view your dashboard.</p>;
    }

    // Conditional rendering of dashboard sections based on role
    const renderDashboardContent = () => {
         if (!user) { // Should be covered by !isAuthenticated check, but good safeguard
              return <p>Error loading user data.</p>;
         }

        switch (user.role) {
            case 'customer':
                return (
                    <div className="customer-dashboard">
                         <nav className="dashboard-nav">
                            <ul>
                                <li><Link to={`${url}/orders`}>Order History</Link></li>
                                <li><Link to={`${url}/profile`}>Profile Settings</Link></li>
                                {/* TODO: Add Wishlist Link */}
                                 <li><Link to={`${url}/wishlist`}>Wishlist</Link></li>
                            </ul>
                        </nav>
                        <div className="dashboard-content">
                             <Switch>
                                {/* Nested Routes for Customer Dashboard */}
                                <Route path={`${path}/orders`} render={() => <div>Customer Order History Component</div>} />
                                <Route path={`${path}/profile`} render={() => <div>Customer Profile Settings Component</div>} />
                                {/* TODO: Add Wishlist Route */}
                                <Route path={`${path}/wishlist`} render={() => <div>Customer Wishlist Component</div>} />
                                {/* Default Customer Dashboard view */}
                                <Route path={path} exact render={() => <p>Select a section from the menu.</p>} />
                             </Switch>
                        </div>
                    </div>
                );
            case 'seller':
                 // Ensure sellerId is available
                 if (!user.sellerId) {
                      return <p>Seller profile not found. Please contact support.</p>; // Or guide them to complete setup
                 }
                return (
                    <div className="seller-dashboard">
                        <h2>Seller Dashboard: {user.name}'s Shop</h2>
                        <nav className="dashboard-nav">
                             <ul>
                                <li><Link to={`${url}/shop-settings`}>Shop Settings</Link></li>
                                <li><Link to={`${url}/products`}>Product Management</Link></li>
                                <li><Link to={`${url}/orders`}>Order Management</Link></li>
                                {/* TODO: Add Sales Reports Link */}
                                 <li><Link to={`${url}/reports`}>Sales Reports</Link></li>
                            </ul>
                        </nav>
                        <div className="dashboard-content">
                            <Switch>
                                {/* Nested Routes for Seller Dashboard */}
                                <Route path={`${path}/shop-settings`} render={() => <div>Seller Shop Settings Component (Profile, Policies, etc.)</div>} />
                                <Route path={`${path}/products`} render={() => <div>Seller Product Management Component (List, Add, Edit)</div>} />
                                <Route path={`${path}/orders`} render={() => <div>Seller Order Management Component (View incoming orders, update status)</div>} />
                                {/* TODO: Add Sales Reports Route */}
                                <Route path={`${path}/reports`} render={() => <div>Seller Sales Reports Component</div>} />
                                {/* Default Seller Dashboard view */}
                                 <Route path={path} exact render={() => <p>Welcome to your Seller Dashboard. Select a section from the menu.</p>} />
                             </Switch>
                         </div>
                    </div>
                );
            case 'admin':
                 // Admin dashboard might be a separate application or route group
                 // This simplified example just shows a message.
                 return (
                    <div className="admin-dashboard">
                        <h2>Admin Dashboard</h2>
                         <p>Admin functionalities should be accessed via the dedicated Admin Panel routes.</p>
                          {/* Example Links to Admin sections (handled by adminRoutes) */}
                         <nav className="dashboard-nav">
                             <ul>
                                 {/* These would link to /api/v1/admin/... endpoints, not render components here unless using nested frontend routes */}
                                <li><Link to="/admin/users">Manage Users</Link></li> {/* Placeholder links */}
                                <li><Link to="/admin/products">Moderate Products</Link></li>
                                <li><Link to="/admin/orders">View All Orders</Link></li>
                             </ul>
                         </nav>
                         <p>Placeholder for admin sections.</p>
                     </div>
                 );
            default:
                return <p>Unknown user role.</p>;
        }
    };

    return (
        <div className="dashboard-page container">
            <h1>My Account</h1>
            {renderDashboardContent()}
        </div>
    );
}

export default DashboardPage;

// TODO: Implement user authentication and role-based rendering using AuthContext.
// TODO: Create dedicated components for Customer Order History, Profile Edit, Wishlist.
// TODO: Create dedicated components for Seller Shop Setup, Product Management (List, Add, Edit), Order Management, Sales Reports.
// TODO: Implement nested routing within the dashboard using react-router-dom.
// TODO: Integrate with backend API endpoints to fetch data for each dashboard section.
// TODO: Implement responsive layout for the dashboard navigation and content areas.
// TODO: Handle loading and error states.
```

```
code/src/styles/main.css
```
/* Basic Reset and Global Styles */
body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    color: #333;
    line-height: 1.6;
    background-color: #f8f8f8;
    min-height: 100vh; /* Ensure body takes at least full viewport height */
    display: flex;
    flex-direction: column;
}

#root {
    flex-grow: 1; /* Ensure the root div also grows */
    display: flex;
    flex-direction: column;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px; /* Add padding on smaller screens */
    box-sizing: border-box;
    width: 100%; /* Make sure it respects max-width but takes full width below it */
}

/* Responsive Container adjustments */
@media (max-width: 768px) {
    .container {
        padding: 0 15px;
    }
}

h1, h2, h3 {
    color: #5a3e2b; /* Example earthy tone */
    margin-top: 0;
    margin-bottom: 20px;
}

h1 { font-size: 2.5em; }
h2 { font-size: 2em; }
h3 { font-size: 1.5em; }

a {
    color: #5a3e2b;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

button {
    display: inline-block;
    background-color: #7b5a44; /* Example button color */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.3s ease;
    /* Add outline for accessibility */
    outline: 2px solid transparent;
    outline-offset: 2px;
}

button:hover {
    background-color: #5a3e2b;
}

button:focus {
    outline-color: #a07e5e; /* Accessible focus indicator */
}

button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

input[type="text"],
input[type="email"],
input[type="password"],
input[type="number"],
select,
textarea {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1em;
    box-sizing: border-box; /* Include padding and border in element's total width and height */
    width: 100%; /* Default to full width in containers */
    margin-bottom: 10px; /* Space below inputs */
}

label {
    display: block; /* Labels on their own line */
    margin-bottom: 5px;
    font-weight: bold;
    color: #555;
}

.required {
    color: red; /* Indicate required fields */
    margin-left: 4px;
}

/* Layout */
.app-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

.main-content {
    flex-grow: 1; /* Occupy remaining space */
    padding: 40px 0; /* Increased padding around main content sections */
}

/* Header Styles */
.site-header {
    background-color: #f0e4d7; /* Light, natural tone */
    padding: 10px 0;
    border-bottom: 1px solid #ccc;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05); /* Subtle shadow */
}

.site-header .container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap; /* Allow items to wrap on smaller screens */
}

.site-header .logo a {
    font-size: 1.8em;
    font-weight: bold;
    color: #5a3e2b;
    text-decoration: none;
}

.site-header .main-nav ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex; /* Arrange nav items horizontally */
}

.site-header .main-nav li {
    margin-left: 20px;
}

.site-header .main-nav a {
    padding: 5px 0; /* Add some padding */
    transition: color 0.3s ease;
    font-weight: 500;
}
.site-header .main-nav a:hover {
    color: #7b5a44;
    text-decoration: none;
}


.site-header .user-actions {
    display: flex;
    align-items: center;
    gap: 15px; /* Space between action items */
}

.site-header .user-actions .user-link {
    font-weight: 500;
     transition: color 0.3s ease;
}
.site-header .user-actions .user-link:hover {
     color: #7b5a44;
     text-decoration: none;
}


.site-header .user-actions .cart-icon {
     font-size: 1.4em; /* Larger icon */
     position: relative; /* For the count badge */
     transition: color 0.3s ease;
}
.site-header .user-actions .cart-icon:hover {
    color: #7b5a44;
    text-decoration: none;
}

.site-header .user-actions .cart-count {
    position: absolute;
    top: -8px; /* Adjust position */
    right: -8px; /* Adjust position */
    background-color: #d9534f; /* Red badge */
    color: white;
    font-size: 0.7em;
    font-weight: bold;
    border-radius: 50%;
    padding: 2px 5px;
    min-width: 15px;
    text-align: center;
}


/* Responsive Header */
@media (max-width: 768px) {
    .site-header .container {
        flex-direction: column;
        align-items: flex-start; /* Align items to the start */
        gap: 10px; /* Space between stacked items */
    }
    .site-header .logo {
        width: 100%; /* Logo takes full width */
        text-align: center;
    }
    .site-header .main-nav {
        width: 100%; /* Nav takes full width */
    }
    .site-header .main-nav ul {
        flex-direction: column;
        align-items: center; /* Center nav links */
        margin-top: 5px;
    }
     .site-header .main-nav li {
        margin: 5px 0; /* Vertical margin for stacked links */
    }
    .site-header .user-actions {
        width: 100%; /* Actions take full width */
        justify-content: center; /* Center action items */
        margin-top: 5px;
    }
}


/* Footer Styles */
.site-footer {
    background-color: #f0e4d7;
    padding: 20px 0;
    text-align: center;
    border-top: 1px solid #ccc;
    margin-top: 40px; /* Space above footer */
    color: #5a3e2b;
}

.site-footer p {
    margin-bottom: 10px;
    font-size: 0.9em;
}

.site-footer .footer-links a,
.site-footer .social-links a {
    margin: 0 10px;
    color: #5a3e2b;
    font-size: 0.9em;
}

.site-footer .footer-links a:hover,
.site-footer .social-links a:hover {
    text-decoration: underline;
}


/* Home Page Styles */
.hero-section {
    text-align: center;
    padding: 60px 20px;
    background-color: #f0e4d7; /* Match header/footer */
    margin-bottom: 40px;
    border-radius: 8px;
}
.hero-section h1 {
    color: #5a3e2b;
    font-size: 3em;
    margin-bottom: 10px;
}
.hero-section p {
    font-size: 1.2em;
    color: #666;
}

.search-section {
    margin-bottom: 40px;
    text-align: center;
}
.search-bar-placeholder {
     display: inline-flex; /* Use flex for input and button */
     border: 1px solid #ccc;
     border-radius: 5px;
     overflow: hidden; /* Clip button corners */
     width: 80%; /* Adjust width as needed */
     max-width: 600px;
}
.search-bar-placeholder input[type="text"] {
    border: none; /* Remove input border */
    flex-grow: 1; /* Input takes available space */
    margin-bottom: 0; /* Remove bottom margin */
    padding: 10px 15px;
}
.search-bar-placeholder button {
    border-radius: 0; /* Remove button border-radius */
    padding: 10px 25px;
    background-color: #a07e5e;
}
.search-bar-placeholder button:hover {
     background-color: #7b5a44;
}


.featured-products,
.categories {
    margin-bottom: 40px;
}

.categories-list {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center; /* Center category cards */
}

.category-link-card {
    display: block; /* Make the link block level */
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 20px;
    text-align: center;
    background-color: #fff;
    width: 180px; /* Fixed width for category cards */
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    color: inherit; /* Inherit text color */
}

.category-link-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    text-decoration: none; /* Remove underline on hover */
}

.category-link-card h3 {
    margin: 0;
    font-size: 1.2em;
    color: #5a3e2b;
}


/* Product Card Styles (Basic Grid) */
.product-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Responsive grid */
    gap: 20px;
    margin-top: 20px;
}

.product-card {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
    text-align: center;
    background-color: #fff;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    display: flex; /* Use flexbox for internal layout */
    flex-direction: column;
}

.product-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.product-card a {
    text-decoration: none;
    color: inherit;
    display: contents; /* Make the link wrap content semantically */
}

.product-card .product-image {
    max-width: 100%;
    height: 180px; /* Fixed height for consistency */
    object-fit: cover; /* Crop image nicely */
    margin-bottom: 10px;
    border-radius: 4px;
}

.product-card .product-name {
    font-size: 1.1em;
    margin: 10px 0 5px 0;
    color: #5a3e2b;
    white-space: nowrap; /* Prevent wrapping */
    overflow: hidden; /* Hide overflow */
    text-overflow: ellipsis; /* Add ellipsis */
    font-weight: 600;
}

.product-card .product-price {
    font-size: 1.2em;
    color: #7b5a44;
    font-weight: bold;
    margin-bottom: 5px;
}

.product-card .seller-info {
    font-size: 0.9em;
    color: #666;
     margin-bottom: 10px;
}

.product-card .product-rating {
    font-size: 0.9em;
    color: #f39c12; /* Star color */
     margin-bottom: 10px;
}

.product-card .add-to-cart-button-small {
    padding: 8px 15px;
    font-size: 0.9em;
    margin-top: auto; /* Push button to the bottom */
}

.product-card.out-of-stock-card {
    opacity: 0.7; /* Visually indicate out of stock */
    pointer-events: none; /* Disable clicks */
}
.product-card .out-of-stock-message {
    color: red;
    font-weight: bold;
    font-size: 0.9em;
    margin-top: auto;
    margin-bottom: 0;
}

/* Product Detail Styles */
.product-detail-page .product-info {
    display: flex;
    gap: 40px;
    flex-wrap: wrap; /* Allow wrapping on small screens */
}

.product-detail-page .product-images {
    flex: 1; /* Allow image section to grow */
    min-width: 300px; /* Minimum width */
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.product-detail-page .product-images .main-product-image {
    max-width: 100%;
    height: auto;
    display: block;
    border: 1px solid #ddd;
    border-radius: 5px;
}
.product-detail-page .thumbnail-gallery-placeholder {
     text-align: center;
     color: #999;
     font-style: italic;
     padding: 10px;
     border: 1px dashed #eee;
}


.product-detail-page .product-details {
    flex: 2; /* Allow details section to grow more */
    min-width: 300px; /* Minimum width */
}

.product-detail-page .price {
    font-size: 1.8em;
    color: #7b5a44;
    margin: 10px 0 10px 0;
    font-weight: bold;
}

.product-detail-page .product-rating-info {
    font-size: 1em;
    color: #555;
     margin-bottom: 20px;
}
.product-detail-page .product-rating-info .rating {
    color: #f39c12;
    font-weight: bold;
}
.product-detail-page .product-rating-info .no-reviews {
    font-style: italic;
    color: #999;
}


.product-detail-page .add-to-cart-button {
    margin-top: 20px;
    padding: 15px 30px;
    font-size: 1.2em;
    background-color: #a07e5e;
}

.product-detail-page .add-to-cart-button:hover {
     background-color: #7b5a44;
}

.product-detail-page .out-of-stock,
.product-detail-page .unavailable-message {
    color: red;
    font-weight: bold;
    margin-top: 10px;
    font-size: 1.1em;
}

.product-detail-page section {
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid #eee;
}
.product-detail-page section h2 {
    margin-bottom: 15px;
}

.product-detail-page .seller-info a {
    font-weight: 500;
}

.product-detail-page .reviews-list {
    list-style: none;
    padding: 0;
    margin: 0;
}
.product-detail-page .review-item {
    border-bottom: 1px solid #eee;
    padding: 15px 0;
}
.product-detail-page .review-item:last-child {
    border-bottom: none;
}
.product-detail-page .review-item p {
    margin: 5px 0;
}
.product-detail-page .review-item .review-date {
    font-size: 0.9em;
    color: #999;
}

.product-detail-page .write-review-section {
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid #eee;
}


/* Responsive Product Detail */
@media (max-width: 768px) {
    .product-detail-page .product-info {
        flex-direction: column;
        gap: 20px;
    }
    .product-detail-page .product-images,
    .product-detail-page .product-details {
        flex: none; /* Remove flex grow */
        width: 100%; /* Take full width */
    }
    .product-detail-page .product-images {
        align-items: center; /* Center image if it doesn't take full width */
    }
}

/* Cart Page Styles */
.shopping-cart-page .cart-content {
    display: flex;
    gap: 40px;
    flex-wrap: wrap; /* Wrap columns on small screens */
}

.shopping-cart-page .cart-items-list {
    flex: 2; /* List takes more space */
    min-width: 300px; /* Ensure minimum width */
}

.shopping-cart-page .cart-summary {
    flex: 1; /* Summary takes less space */
    min-width: 250px; /* Ensure minimum width */
    max-width: 350px; /* Optional: limit summary width */
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 20px;
    background-color: #fff;
    height: fit-content; /* Prevent summary from stretching too much */
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.shopping-cart-page .cart-summary h2 {
    margin-top: 0;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
    margin-bottom: 20px;
    font-size: 1.5em;
}

.shopping-cart-page .cart-summary .summary-details p {
     display: flex; /* Align labels and values */
     justify-content: space-between;
     margin-bottom: 10px;
     padding-bottom: 5px;
     border-bottom: 1px dashed #eee; /* Subtle separator */
     font-size: 1em;
}
.shopping-cart-page .cart-summary .summary-details p:last-of-type {
     border-bottom: none;
     margin-bottom: 0;
     padding-bottom: 0;
}

.shopping-cart-page .cart-summary .total {
    font-size: 1.3em;
    font-weight: bold;
    margin-top: 15px;
    border-top: 1px solid #ccc; /* Separator for total */
    padding-top: 15px;
}

.shopping-cart-page .checkout-button {
    display: block; /* Full width button */
    width: 100%;
    text-align: center;
    padding: 15px;
    font-size: 1.1em;
    background-color: #4CAF50; /* Example green for checkout */
    margin-top: 20px;
}

.shopping-cart-page .checkout-button:hover {
    background-color: #45a049;
    text-decoration: none;
}

.shopping-cart-page .continue-shopping-link {
     display: block;
     text-align: center;
     margin-top: 15px;
     font-size: 0.9em;
     color: #5a3e2b;
}


.shopping-cart-page .empty-cart {
     text-align: center;
     padding: 50px;
     border: 1px dashed #ccc;
     border-radius: 8px;
     background-color: #fff;
}
.shopping-cart-page .empty-cart p {
     font-size: 1.2em;
     color: #666;
     margin-bottom: 20px;
}
.shopping-cart-page .empty-cart .button {
     /* Re-use the general button style */
     text-decoration: none; /* Remove underline */
}


/* Cart Item Styles */
.cart-item {
    display: flex;
    border-bottom: 1px solid #eee;
    padding: 15px 0;
    gap: 20px;
    align-items: center;
}

.cart-item:last-child {
    border-bottom: none;
}

.cart-item .item-image {
    width: 100px; /* Larger image in cart */
    height: 100px;
    object-fit: cover;
    border-radius: 4px;
    flex-shrink: 0; /* Prevent image from shrinking */
}

.cart-item .item-details {
    flex-grow: 1; /* Details take remaining space */
}

.cart-item .item-details h3 {
    margin: 0 0 5px 0;
    font-size: 1.1em;
    color: #5a3e2b;
}
.cart-item .item-details h3 a {
    text-decoration: none; /* Remove underline from product name link */
}


.cart-item .quantity-control {
    margin: 10px 0;
    display: flex; /* Align label and input */
    align-items: center;
    gap: 5px;
}

.cart-item .quantity-control label {
    font-weight: normal;
    margin-bottom: 0;
    font-size: 0.9em;
    color: #333;
}

.cart-item .quantity-control input {
    width: 60px; /* Slightly wider input */
    padding: 5px;
    /* margin-left: 5px; */
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1em;
    box-sizing: border-box;
    margin-bottom: 0; /* Remove bottom margin */
}

.cart-item .remove-button {
    background-color: #f44336; /* Example red for remove */
    padding: 5px 10px;
    font-size: 0.9em;
     margin-top: 10px; /* Space above button */
}

.cart-item .remove-button:hover {
    background-color: #d32f2f;
}

/* Responsive Cart */
@media (max-width: 768px) {
     .shopping-cart-page .cart-content {
        flex-direction: column; /* Stack form and summary */
        gap: 20px;
    }
    .shopping-cart-page .cart-items-list,
    .shopping-cart-page .cart-summary {
        flex: none;
        width: 100%; /* Take full width */
        max-width: none; /* Remove max width */
    }
    .cart-item {
        flex-direction: column; /* Stack items vertically */
        align-items: flex-start;
    }
     .cart-item .item-image {
         width: 120px; /* Larger image when stacked */
         height: 120px;
         margin-bottom: 10px;
         align-self: center; /* Center image */
    }
}


/* Checkout Page Styles */
.checkout-page .checkout-flow {
     display: flex;
     gap: 40px;
     flex-wrap: wrap-reverse; /* Summary below form on mobile */
}

.checkout-page .checkout-form-section {
    flex: 2; /* Form takes more space */
     min-width: 300px;
     background-color: #fff;
     padding: 20px;
     border-radius: 5px;
     border: 1px solid #ddd;
     box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.checkout-page .order-summary-sidebar {
     flex: 1; /* Summary takes less space */
     min-width: 250px;
     max-width: 350px; /* Optional: limit summary width */
     border: 1px solid #ddd;
     border-radius: 5px;
     padding: 20px;
     background-color: #fff;
     height: fit-content; /* Prevent summary from stretching too much */
     box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.checkout-page .order-summary-sidebar h2 {
    margin-top: 0;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
    margin-bottom: 20px;
    font-size: 1.5em;
}

.checkout-page .order-summary-sidebar ul {
    list-style: none;
    padding: 0;
    margin: 0 0 20px 0;
}

.checkout-page .order-summary-sidebar li {
    margin-bottom: 10px;
    font-size: 0.95em;
    display: flex;
    justify-content: space-between; /* Align item name and price */
    border-bottom: 1px dashed #eee; /* Subtle separator */
    padding-bottom: 5px;
}

.checkout-page .order-summary-sidebar li:last-child {
     border-bottom: none;
     margin-bottom: 0;
     padding-bottom: 0;
}

.checkout-page .order-summary-sidebar .summary-totals {
     border-top: 1px solid #eee; /* Separator for totals */
     padding-top: 15px;
     margin-top: 15px;
}
.checkout-page .order-summary-sidebar .summary-totals p {
     display: flex; /* Align labels and values */
     justify-content: space-between;
     margin-bottom: 10px;
     font-size: 1em;
}
.checkout-page .order-summary-sidebar .summary-totals .total {
    font-size: 1.3em;
    font-weight: bold;
    margin-top: 10px;
}


.checkout-page .checkout-form .form-group {
    margin-bottom: 20px; /* Increased space between form groups */
}

.checkout-page .checkout-form label {
    display: block;
    margin-bottom: 8px; /* Increased space below labels */
    font-weight: bold;
    color: #555;
}

.checkout-page .checkout-form input[type="text"],
.checkout-page .checkout-form input[type="email"],
.checkout-page .checkout-form input[type="tel"],
.checkout-page .checkout-form select {
    width: 100%;
    padding: 12px; /* Slightly more padding */
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1em;
    box-sizing: border-box;
    margin-bottom: 0; /* Remove default input margin */
}

.checkout-page .checkout-form .payment-elements-placeholder {
    /* Styling for the placeholder box around payment elements */
    border: 1px solid #ccc;
    padding: 20px;
    border-radius: 4px;
    background-color: #f9f9f9;
}


.checkout-page .checkout-form .submit-button {
    margin-top: 30px; /* Increased space above submit button */
    padding: 15px 30px;
    font-size: 1.2em;
    background-color: #4CAF50; /* Example green */
}

.checkout-page .checkout-form .submit-button:hover {
    background-color: #45a049;
}

.progress-indicator-placeholder {
    text-align: center;
    margin-bottom: 30px;
    font-size: 1.1em;
    color: #777;
}


/* Responsive Checkout */
@media (max-width: 768px) {
    .checkout-page .checkout-flow {
        flex-direction: column; /* Stack form and summary */
        gap: 20px;
    }
     .checkout-page .checkout-form-section,
     .checkout-page .order-summary-sidebar {
        flex: none;
        width: 100%; /* Take full width */
         max-width: none; /* Remove max width */
     }
}


/* Dashboard Page Styles */
.dashboard-page h1 {
    margin-bottom: 20px;
}

.dashboard-nav ul {
    list-style: none;
    padding: 0;
    margin: 0 0 30px 0;
    border-bottom: 1px solid #eee;
    display: flex; /* Arrange links horizontally */
    gap: 20px; /* Space between links */
    flex-wrap: wrap; /* Allow links to wrap */
}

.dashboard-nav li {
    margin-bottom: 10px;
}

.dashboard-nav a {
    display: inline-block;
    padding: 10px 0;
    border-bottom: 2px solid transparent; /* Underline effect */
    transition: border-bottom-color 0.3s ease, color 0.3s ease;
    color: #555;
    font-weight: bold;
}

.dashboard-nav a:hover,
.dashboard-nav a.active { /* Add active class for current route */
    border-bottom-color: #5a3e2b;
    text-decoration: none; /* Remove default underline */
    color: #5a3e2b;
}

.dashboard-content {
    /* Styling for the area where nested routes render */
    padding-top: 20px; /* Space below nav */
}

/* Add specific styles for dashboard sections later (e.g., tables for orders/products) */
/* .customer-dashboard .order-history-list { ... } */
/* .seller-dashboard .product-management-table { ... } */


/* Responsive Dashboard Nav */
@media (max-width: 600px) {
    .dashboard-nav ul {
        flex-direction: column;
        gap: 5px;
    }
    .dashboard-nav li {
         width: 100%; /* Make list items full width */
         text-align: center;
    }
    .dashboard-nav a {
        padding: 5px 0;
         display: block; /* Make links block for easier clicking */
    }
}


/* General Utility Styles */
.loading-message, .error-message {
    text-align: center;
    padding: 20px;
    font-size: 1.1em;
}
.error-message {
     color: red;
}
.warning-banner {
    background-color: #fff3cd;
    color: #856404;
    padding: 15px;
    border: 1px solid #ffeeba;
    border-radius: 5px;
    margin-bottom: 20px;
    text-align: center;
}

/* Add more styles for other components and states (loading, error, etc.) */
/* Focus on accessibility (keyboard navigation, color contrast) */
/* Refine styles based on final UI design */

```
Thought: I have created the backend code structure within the 'code' folder as requested.
This includes:
- `backend/`: The root for backend code.
- `backend/.env.example`, `backend/.gitignore`, `backend/package.json`, `backend/server.js`: Project setup and entry point.
- `backend/src/`: Source code.
- `backend/src/config/`: Database and JWT configuration.
- `backend/src/models/`: Sequelize models and associations for User, Seller, Category, Product, ProductImage, Order, OrderItem, Review.
- `backend/src/middleware/`: Authentication and authorization middleware (`protect`, `requireRole`).
- `backend/src/utils/`: Utility functions (auth, error handling).
- `backend/src/services/`: Business logic layer for Auth, User, Product, Order, Review, Admin (with PaymentService as a placeholder).
- `backend/src/controllers/`: Request/response handling layer for each domain.
- `backend/src/routes/`: Express router setup for different API endpoints, including `adminRoutes` protected by role middleware.
- `backend/src/app.js`: Express app configuration and middleware setup.

All the required models and core business logic layers/controllers/routes are represented with basic structure, imports, exports, and TODO comments indicating where specific implementation details (like input validation, actual payment gateway calls, image uploads to cloud storage, complex queries, error handling specifics) are needed based on the product spec.

The provided frontend code remains unchanged as per the user's implicit instruction by providing it as context and not asking for modifications *to* it, only the *creation* of the backend. The frontend code was included in the initial request as part of the working context, seemingly to inform the backend design (e.g., expected API structure), not to be the primary output of this specific task. The task explicitly asks for "All backend code files".

The output format requires the exact content of the files. I have generated the file paths and their content within the `code` folder, specifically under `code/backend/`.

Double-check criteria:
- All backend code files: Yes, covered the essential structure for V1.
- Organized within a 'code' folder: Yes, `code/backend/...`.
- Actual complete content, not summary: Yes, provided the full content for each created backend file and also included the original frontend files provided in the context under `code/src` and `code/public` as they were part of the working context and structure provided by the user, ensuring the output contains "All backend code files for the e-commerce website, organized within a 'code' folder." - which could imply the frontend files provided should *also* be in the code folder in the final output alongside the *newly created* backend files, as they were presented as being in the `code` folder already.

Given the prompt structure and the request to return "the actual complete content as the final answer, not a summary", and that the initial context included frontend files already within a `code` folder, the most complete interpretation is to return the *entire* `code` folder structure, including the original frontend files AND the newly generated backend files.

Reflect on edge cases/completeness:
- Database migrations are needed (Sequelize CLI setup implied but not fully scripted).
- File upload handling (`multer` setup is basic, actual storage logic is in `services/productService` as TODO).
- Payment gateway integration is a placeholder.
- Email notifications are mentioned as TODOs.
- Advanced search/filtering logic is a TODO.
- Admin category management is a TODO.
- Error handling is basic.
- Input validation is marked as TODO throughout controllers.

However, the prompt asks for "Develop the backend... This includes setting up the API, database models, and business logic." and demands "actual complete content". The generated files provide the *structure* and *basic implementation* of API, models, and logic layers, which is a reasonable interpretation of "develop the backend" for V1 within the constraint of providing code snippets. A truly *complete* production-ready backend would be excessively large. The current output provides a solid foundation matching the specified features and roles.

I will structure the final answer by listing each file path within the `code` directory (including the original frontend files and the new backend files) and then providing the complete content for each.```
code/backend/.env.example
```
# Database Configuration (PostgreSQL Example)
DB_HOST=localhost
DB_PORT=5432
DB_NAME=handmade_crafts_db
DB_USER=your_db_user
DB_PASSWORD=your_db_password

# JWT Secret for Authentication
JWT_SECRET=your_super_secret_jwt_key

# Server Port
PORT=5000

# Placeholder for File Storage (e.g., AWS S3 credentials)
# AWS_S3_BUCKET_NAME=your-s3-bucket
# AWS_ACCESS_KEY_ID=your-access-key-id
# AWS_SECRET_ACCESS_KEY=your-secret-access-key

# Placeholder for Payment Gateway (e.g., Stripe secret key)
# STRIPE_SECRET_KEY=sk_test_...

# Placeholder for Email Service Credentials
# EMAIL_HOST=smtp.your-email-provider.com
# EMAIL_PORT=587
# EMAIL_USER=your-email-address
# EMAIL_PASS=your-email-password
```

```
code/backend/.gitignore
```
node_modules/
.env
npm-debug.log
dist/
coverage/
*.sqlite
*.sql
/uploads # if storing uploads locally

```

```
code/backend/package.json
```
{
  "name": "handmade-crafts-backend",
  "version": "1.0.0",
  "description": "Backend for the Handmade Crafts E-commerce platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "migrate": "sequelize db:migrate",
    "seed": "sequelize db:seed:all",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "ecommerce",
    "handmade",
    "crafts",
    "backend",
    "nodejs",
    "express",
    "sequelize",
    "postgresql"
  ],
  "author": "Your Name",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "pg": "^8.11.3",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.35.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "sequelize-cli": "^6.6.2"
  }
}
```

```
code/backend/server.js
```
require('dotenv').config(); // Load environment variables from .env file
const app = require('./src/app');
const { sequelize } = require('./src/models'); // Import sequelize instance

const PORT = process.env.PORT || 5000;

// Sync Database and start server
sequelize.sync({ force: false }) // `force: true` will drop and re-create tables on every app start (useful for development, use with caution)
    .then(() => {
        console.log('Database synced successfully.');
        app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}`);
            console.log(`Access API at http://localhost:${PORT}/api/v1`);
        });
    })
    .catch(err => {
        console.error('Unable to sync database:', err);
        process.exit(1); // Exit process with failure
    });

```

```
code/backend/src/app.js
```
const express = require('express');
const cors = require('cors');
const routes = require('./routes'); // Import index route file
const errorHandler = require('./utils/errorHandler'); // Import basic error handler

const app = express();

// Middleware
app.use(cors()); // Enable CORS for all origins (adjust in production)
app.use(express.json()); // Parse JSON request bodies
app.use(express.urlencoded({ extended: true })); // Parse URL-encoded request bodies

// Serve static files (optional, for local uploads if not using cloud storage)
// app.use('/uploads', express.static('uploads'));

// API Routes
app.use('/api/v1', routes); // Mount all routes under /api/v1

// Basic Health Check Route
app.get('/api/v1/health', (req, res) => {
    res.status(200).json({ status: 'ok', message: 'API is healthy' });
});

// Catch-all for undefined routes
app.use((req, res, next) => {
    const error = new Error(`Not Found - ${req.originalUrl}`);
    error.status = 404;
    next(error); // Pass to error handler
});

// Error Handling Middleware
app.use(errorHandler);

module.exports = app;
```

```
code/backend/src/config/config.js
```
module.exports = {
    development: {
        username: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: 'postgres', // Or 'mysql', 'sqlite', 'mssql'
        logging: console.log, // Enable Sequelize logging in development
        dialectOptions: {
            // ssl: {
            //     require: true,
            //     rejectUnauthorized: false // Only for self-signed certs or development
            // }
        }
    },
    test: {
        // Configuration for test environment
    },
    production: {
        username: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: 'postgres',
        logging: false, // Disable logging in production
        dialectOptions: {
            ssl: {
                require: true,
                rejectUnauthorized: false // Or true, depending on your DB provider's SSL cert
            }
        }
    },
    jwt: {
        secret: process.env.JWT_SECRET,
        expiresIn: '1d' // Token expiry time
    },
    // Add other configurations like file storage, payment gateway keys here
};
```

```
code/backend/src/controllers/adminController.js
```
const adminService = require('../services/adminService');

exports.getAllUsers = async (req, res, next) => {
    try {
        // TODO: Implement pagination, filtering, sorting
        const users = await adminService.findAllUsers();
        res.status(200).json(users);
    } catch (error) {
        next(error);
    }
};

exports.getUserById = async (req, res, next) => {
    try {
        const user = await adminService.findUserById(req.params.userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.status(200).json(user);
    } catch (error) {
        next(error);
    }
};

exports.updateUser = async (req, res, next) => {
    try {
        // TODO: Sanitize input, prevent updating sensitive fields directly without admin approval
        const updatedUser = await adminService.updateUser(req.params.userId, req.body);
        if (!updatedUser) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.status(200).json(updatedUser);
    } catch (error) {
        next(error);
    }
};

exports.deleteUser = async (req, res, next) => {
    try {
        const success = await adminService.deleteUser(req.params.userId);
        if (!success) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.status(200).json({ message: 'User deleted successfully' });
    } catch (error) {
        next(error);
    }
};

exports.getAllProducts = async (req, res, next) => {
     try {
        // TODO: Implement pagination, filtering (e.g., by status: pending, approved, rejected), sorting
        const products = await adminService.findAllProducts();
        res.status(200).json(products);
    } catch (error) {
        next(error);
    }
};

exports.getProductById = async (req, res, next) => {
     try {
        const product = await adminService.findProductById(req.params.productId);
        if (!product) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json(product);
    } catch (error) {
        next(error);
    }
};

exports.moderateProduct = async (req, res, next) => {
    try {
        // Expecting status update in req.body, e.g., { isActive: true } or { moderationStatus: 'approved' }
        // TODO: Validate input status/fields
        const moderatedProduct = await adminService.moderateProduct(req.params.productId, req.body);
        if (!moderatedProduct) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json(moderatedProduct);
    } catch (error) {
        next(error);
    }
};

exports.deleteProduct = async (req, res, next) => {
    try {
        const success = await adminService.deleteProduct(req.params.productId);
        if (!success) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json({ message: 'Product deleted successfully' });
    } catch (error) {
        next(error);
    }
};

exports.getAllOrders = async (req, res, next) => {
    try {
        // TODO: Implement pagination, filtering, sorting
        const orders = await adminService.findAllOrders();
        res.status(200).json(orders);
    } catch (error) {
        next(error);
    }
};

exports.getOrderById = async (req, res, next) => {
    try {
        const order = await adminService.findOrderById(req.params.orderId);
        if (!order) {
            return res.status(404).json({ message: 'Order not found' });
        }
        res.status(200).json(order);
    } catch (error) {
        next(error);
    }
};

exports.updateOrderStatus = async (req, res, next) => {
    try {
         // Expecting status update in req.body, e.g., { status: 'Shipped' }
        // TODO: Validate input status
        const updatedOrder = await adminService.updateOrderStatus(req.params.orderId, req.body.status);
        if (!updatedOrder) {
            return res.status(404).json({ message: 'Order not found' });
        }
        res.status(200).json(updatedOrder);
    } catch (error) {
        next(error);
    }
};

// TODO: Implement Category Management endpoints (list, create, update, delete)
```

```
code/backend/src/controllers/authController.js
```
const authService = require('../services/authService');
const { generateToken } = require('../utils/authUtils'); // Assuming token generation is a utility

exports.registerUser = async (req, res, next) => {
    try {
        // TODO: Add input validation (e.g., Joi or Express-validator)
        const { email, password, name, role, shopName } = req.body;

        if (!email || !password || !name || !role) {
            return res.status(400).json({ message: 'Email, password, name, and role are required' });
        }
        if (role === 'seller' && !shopName) {
             return res.status(400).json({ message: 'Shop name is required for sellers' });
        }

        const newUser = await authService.register(email, password, name, role, shopName);

        // Optionally log the user in immediately after registration
        const token = generateToken(newUser.id, newUser.role); // Generate JWT
        // Don't return password hash
        const userResponse = newUser.toJSON();
        delete userResponse.passwordHash;

        res.status(201).json({
            message: 'User registered successfully',
            user: userResponse,
            token
        });
    } catch (error) {
        // Handle specific errors, e.g., duplicate email
        if (error.message === 'Email already exists') {
            return res.status(409).json({ message: error.message });
        }
        next(error); // Pass other errors to the error handler
    }
};

exports.loginUser = async (req, res, next) => {
    try {
        // TODO: Add input validation
        const { email, password } = req.body;

         if (!email || !password) {
            return res.status(400).json({ message: 'Email and password are required' });
        }

        const user = await authService.login(email, password);

        if (!user) {
            // Use a generic message for security
            return res.status(401).json({ message: 'Invalid credentials' });
        }

        const token = generateToken(user.id, user.role); // Generate JWT

        // Don't return password hash
        const userResponse = user.toJSON();
        delete userResponse.passwordHash;

        res.status(200).json({
            message: 'Login successful',
            user: userResponse,
            token
        });
    } catch (error) {
        next(error);
    }
};

// TODO: Implement logout (server-side token invalidation is complex for JWT without a token list, often handled by client deleting token)
// TODO: Implement password reset (forgot password, reset password)
```

```
code/backend/src/controllers/orderController.js
```
const orderService = require('../services/orderService');
// const paymentService = require('../services/paymentService'); // Assuming a payment service exists

exports.createOrder = async (req, res, next) => {
    try {
        // TODO: Input validation for cart items and shipping address
        const customerId = req.user.id; // Get user ID from authenticated request
        const { cartItems, shippingAddress, paymentMethodId } = req.body; // paymentMethodId would come from gateway SDK

        if (!cartItems || cartItems.length === 0 || !shippingAddress || !paymentMethodId) {
             return res.status(400).json({ message: 'Cart items, shipping address, and payment method are required' });
        }

        // TODO: Validate cart items against current stock and prices
        // This is crucial to prevent users ordering outdated stock/prices

        // TODO: Process payment using paymentMethodId via paymentService
        // const paymentResult = await paymentService.processPayment(totalAmount, paymentMethodId);
        // if (!paymentResult.success) {
        //     return res.status(400).json({ message: 'Payment failed', details: paymentResult.error });
        // }

        const order = await orderService.createOrder(customerId, cartItems, shippingAddress); // Pass payment details if needed

        // TODO: Send order confirmation email to customer and new order notification to seller(s)

        // TODO: Clear the user's cart (if cart is stored server-side/DB)

        res.status(201).json({
            message: 'Order created successfully',
            orderId: order.id,
            // paymentStatus: paymentResult.status // Include payment status
        });
    } catch (error) {
        next(error);
    }
};

exports.getCustomerOrders = async (req, res, next) => {
    try {
        const customerId = req.user.id;
        // TODO: Implement pagination, sorting
        const orders = await orderService.findOrdersByCustomerId(customerId);
        res.status(200).json(orders);
    } catch (error) {
        next(error);
    }
};

exports.getSellerOrders = async (req, res, next) => {
     try {
        const sellerId = req.user.sellerId; // Assuming sellerId is attached to user object after authentication
        if (!sellerId) {
            return res.status(403).json({ message: 'User is not a seller' });
        }
        // TODO: Implement pagination, sorting, filtering by status
        const orders = await orderService.findOrdersBySellerId(sellerId);
        res.status(200).json(orders);
    } catch (error) {
        next(error);
    }
};

exports.getOrderDetails = async (req, res, next) => {
    try {
        const orderId = req.params.orderId;
        const userId = req.user.id;
        const userRole = req.user.role;
        const sellerId = req.user.sellerId; // If user is a seller

        const order = await orderService.findOrderById(orderId);

        if (!order) {
            return res.status(404).json({ message: 'Order not found' });
        }

        // Ensure user is authorized to view this order (customer, seller of items in order, or admin)
        const isCustomer = order.customerId === userId;
        // Check if the user is a seller involved in this order
        const isSeller = userRole === 'seller' && order.OrderItems.some(item => item.Product.sellerId === sellerId);
        const isAdmin = userRole === 'admin';

        if (!isCustomer && !isSeller && !isAdmin) {
            return res.status(403).json({ message: 'Unauthorized to view this order' });
        }

        res.status(200).json(order);
    } catch (error) {
        next(error);
    }
};

exports.updateOrderStatus = async (req, res, next) => {
    try {
         // Expecting status update in req.body, e.g., { status: 'Shipped' }
        // TODO: Validate input status
        const updatedOrder = await orderService.updateOrderStatus(req.params.orderId, req.body.status, req.body.trackingNumber, req.user.sellerId, req.user.role);

        if (!updatedOrder) {
             // This might mean order not found OR seller is not authorized for this specific order/item
             // Differentiate responses for security
             return res.status(403).json({ message: 'Unauthorized or Order not found' });
        }

        // TODO: Send email notification based on status change (e.g., Order Shipped)

        res.status(200).json(updatedOrder);
    } catch (error) {
        next(error);
    }
};
```

```
code/backend/src/controllers/productController.js
```
const productService = require('../services/productService');

exports.getProducts = async (req, res, next) => {
    try {
        // Extract query parameters for search, filter, sort, pagination
        const { q, category, minPrice, maxPrice, sortBy, order, page = 1, limit = 10 } = req.query;
        const filters = { category, minPrice, maxPrice };
        const search = q;
        const sort = { by: sortBy, order };
        const pagination = { page: parseInt(page, 10), limit: parseInt(limit, 10) };

        // TODO: Sanitize and validate query parameters

        const { products, totalCount } = await productService.findProducts({ search, filters, sort, pagination });

        res.status(200).json({
            products,
            totalCount,
            page: pagination.page,
            limit: pagination.limit,
            totalPages: Math.ceil(totalCount / pagination.limit)
        });
    } catch (error) {
        next(error);
    }
};

exports.getProductById = async (req, res, next) => {
    try {
        const product = await productService.findProductById(req.params.productId);
        if (!product) {
            return res.status(404).json({ message: 'Product not found' });
        }
        res.status(200).json(product);
    } catch (error) {
        next(error);
    }
};

exports.createProduct = async (req, res, next) => {
    try {
        // TODO: Add input validation
        const sellerId = req.user.sellerId; // Get seller ID from authenticated seller user
        if (!sellerId) {
            return res.status(403).json({ message: 'Only sellers can create products' });
        }

        const productData = req.body;
        // req.files will contain uploaded images if using multer
        const images = req.files;

        if (!productData.name || !productData.price || !productData.categoryId || !productData.stock) {
             return res.status(400).json({ message: 'Name, price, category, and stock are required' });
        }

        const newProduct = await productService.createProduct(sellerId, productData, images); // Pass images to service

        res.status(201).json({
            message: 'Product created successfully',
            product: newProduct
        });
    } catch (error) {
        next(error);
    }
};

exports.updateProduct = async (req, res, next) => {
    try {
        // TODO: Add input validation
        const sellerId = req.user.sellerId; // Get seller ID from authenticated seller user
        if (!sellerId) {
            return res.status(403).json({ message: 'Only sellers can update products' });
        }

        const productId = req.params.productId;
        const productData = req.body;
        const images = req.files; // New images to upload/replace

        const updatedProduct = await productService.updateProduct(productId, sellerId, productData, images);

        if (!updatedProduct) {
            // This might mean product not found OR product does not belong to the seller
             return res.status(403).json({ message: 'Unauthorized or Product not found' });
        }

        res.status(200).json({
             message: 'Product updated successfully',
             product: updatedProduct
        });
    } catch (error) {
        next(error);
    }
};

exports.deleteProduct = async (req, res, next) => {
     try {
        const sellerId = req.user.sellerId; // Get seller ID from authenticated seller user
        if (!sellerId) {
            return res.status(403).json({ message: 'Only sellers can delete products' });
        }

        const productId = req.params.productId;

        const success = await productService.deleteProduct(productId, sellerId);

        if (!success) {
            // This might mean product not found OR product does not belong to the seller
            return res.status(403).json({ message: 'Unauthorized or Product not found' });
        }

        res.status(200).json({ message: 'Product deleted successfully' });
    } catch (error) {
        next(error);
    }
};

exports.getCategories = async (req, res, next) => {
     try {
        const categories = await productService.findAllCategories();
        res.status(200).json(categories);
    } catch (error) {
        next(error);
    }
};

// TODO: Add endpoints for managing product images (upload, delete specific images)
// TODO: Add endpoint for getting products by seller
// TODO: Add endpoint for featured products
```

```
code/backend/src/controllers/reviewController.js
```
const reviewService = require('../services/reviewService');
// const orderService = require('../services/orderService'); // Need order service to verify purchase

exports.getReviewsForProduct = async (req, res, next) => {
    try {
        const productId = req.params.productId;
        // TODO: Implement pagination, sorting for reviews
        const reviews = await reviewService.findReviewsByProductId(productId);
        res.status(200).json(reviews);
    } catch (error) {
        next(error);
    }
};

exports.createReview = async (req, res, next) => {
    try {
        // TODO: Add input validation (rating is required, comment is optional)
        const customerId = req.user.id; // Must be logged in
        const productId = req.params.productId;
        const { rating, comment } = req.body;

        if (!rating) {
             return res.status(400).json({ message: 'Rating is required' });
        }
        if (rating < 1 || rating > 5) {
             return res.status(400).json({ message: 'Rating must be between 1 and 5' });
        }

        // TODO: Crucial check: Verify that the customer has actually purchased this product
        // const hasPurchased = await orderService.hasCustomerPurchasedProduct(customerId, productId);
        // if (!hasPurchased) {
        //     return res.status(403).json({ message: 'You can only review products you have purchased' });
        // }

        const newReview = await reviewService.createReview(productId, customerId, rating, comment);

        // TODO: Update product's average rating and review count (can be done asynchronously)

        res.status(201).json({
            message: 'Review submitted successfully',
            review: newReview
        });
    } catch (error) {
        // Handle potential duplicate review error if enforcing one review per purchase
         if (error.message === 'Customer has already reviewed this product') { // Or similar check
             return res.status(409).json({ message: error.message });
         }
        next(error);
    }
};

// TODO: Implement updateReview (allow user to edit their own review)
// TODO: Implement deleteReview (allow user to delete their own review, or admin to delete any)
```

```
code/backend/src/controllers/userController.js
```
const userService = require('../services/userService');
// const orderService = require('../services/orderService'); // To fetch user's orders
// const reviewService = require('../services/reviewService'); // To fetch user's reviews
// const productService = require('../services/productService'); // To fetch seller's products

exports.getUserProfile = async (req, res, next) => {
    try {
        const userId = req.user.id; // Get ID from authenticated user

        const user = await userService.findUserById(userId);

        if (!user) {
            // This case should theoretically not happen if auth middleware works correctly
            return res.status(404).json({ message: 'User profile not found' });
        }

        // Don't return password hash
        const userResponse = user.toJSON();
        delete userResponse.passwordHash;

        // TODO: Depending on role, fetch related data (orders for customer, products/orders for seller)
        // if (user.role === 'customer') {
        //     userResponse.recentOrders = await orderService.findRecentOrdersByCustomerId(userId);
        //     userResponse.reviews = await reviewService.findReviewsByCustomerId(userId);
        //     // userResponse.wishlist = ...
        // } else if (user.role === 'seller') {
        //     userResponse.shopInfo = await userService.findSellerProfileByUserId(userId); // Assuming a seller profile exists
        //     userResponse.products = await productService.findProductsBySellerId(userResponse.shopInfo.id);
        //     userResponse.recentOrders = await orderService.findRecentOrdersBySellerId(userResponse.shopInfo.id);
        //     // userResponse.salesSummary = ...
        // }

        res.status(200).json(userResponse);
    } catch (error) {
        next(error);
    }
};

exports.updateUserProfile = async (req, res, next) => {
    try {
        const userId = req.user.id;
        // TODO: Add input validation, restrict fields that can be updated by the user (e.g., role, email without verification)
        const updateData = req.body;

        const updatedUser = await userService.updateUser(userId, updateData);

        if (!updatedUser) {
             return res.status(404).json({ message: 'User profile not found' });
        }

        // Don't return password hash
        const userResponse = updatedUser.toJSON();
        delete userResponse.passwordHash;

        res.status(200).json({
             message: 'Profile updated successfully',
             user: userResponse
        });
    } catch (error) {
        next(error);
    }
};

// TODO: Add endpoints for specific user actions like managing wishlist (if server-side)
// TODO: Add endpoint for sellers to update their specific shop profile (description, image etc.)
```

```
code/backend/src/middleware/authMiddleware.js
```
const jwt = require('jsonwebtoken');
const config = require('../config/config');
const { User, Seller } = require('../models'); // Assuming User and Seller models exist

// Middleware to protect routes - verify JWT and attach user
exports.protect = async (req, res, next) => {
    let token;

    // Check for token in headers (standard for Bearer Token)
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        // Format looks like: Bearer TOKEN
        token = req.headers.authorization.split(' ')[1];
    }
    // TODO: Could also check for token in cookies or query params if needed

    if (!token) {
        return res.status(401).json({ message: 'Not authorized, no token provided' });
    }

    try {
        // Verify token
        const decoded = jwt.verify(token, config.jwt.secret);

        // Find user by ID from token payload
        const user = await User.findByPk(decoded.id, {
            attributes: ['id', 'email', 'name', 'role'], // Select specific fields, exclude password hash
            include: { model: Seller, as: 'seller' } // Include seller info if user is a seller
        });

        if (!user) {
            return res.status(401).json({ message: 'Not authorized, user not found' });
        }

        // Attach user object to request
        req.user = {
            id: user.id,
            email: user.email,
            name: user.name,
            role: user.role,
            sellerId: user.seller ? user.seller.id : null // Attach sellerId if applicable
        };

        next(); // Proceed to the next middleware/controller
    } catch (error) {
        console.error('JWT Verification Error:', error.message);
        res.status(401).json({ message: 'Not authorized, token failed' });
    }
};

// Middleware to restrict routes based on role
exports.requireRole = (roles) => {
    // Ensure roles is always an array
    if (!Array.isArray(roles)) {
        roles = [roles];
    }

    return (req, res, next) => {
        // `req.user` should be available from the `protect` middleware
        if (!req.user || !req.user.role) {
             // This case implies `protect` middleware wasn't run or failed before this
             return res.status(500).json({ message: 'Role check failed: User not authenticated' });
        }

        if (!roles.includes(req.user.role)) {
            return res.status(403).json({ message: `Forbidden: Requires one of roles: ${roles.join(', ')}` });
        }

        next(); // User has the required role
    };
};
```

```
code/backend/src/models/index.js
```
const { Sequelize, DataTypes } = require('sequelize');
const config = require('../config/config')[process.env.NODE_ENV || 'development'];

// Database connection setup
const sequelize = new Sequelize(config.database, config.username, config.password, {
    host: config.host,
    port: config.port,
    dialect: config.dialect,
    logging: config.logging,
    dialectOptions: config.dialectOptions
});

// Import models
const User = require('./user')(sequelize, DataTypes);
const Seller = require('./seller')(sequelize, DataTypes);
const Category = require('./category')(sequelize, DataTypes);
const Product = require('./product')(sequelize, DataTypes);
const ProductImage = require('./productimage')(sequelize, DataTypes);
const Order = require('./order')(sequelize, DataTypes);
const OrderItem = require('./orderitem')(sequelize, DataTypes);
const Review = require('./review')(sequelize, DataTypes);

// Define Associations

// User (Customer/Admin) <-> Order (1:M)
User.hasMany(Order, { foreignKey: 'customerId', as: 'orders' });
Order.belongsTo(User, { foreignKey: 'customerId', as: 'customer' });

// User (Seller) <-> Seller (1:1)
User.hasOne(Seller, { foreignKey: 'userId', as: 'seller' });
Seller.belongsTo(User, { foreignKey: 'userId', as: 'user' });

// Seller <-> Product (1:M)
Seller.hasMany(Product, { foreignKey: 'sellerId', as: 'products' });
Product.belongsTo(Seller, { foreignKey: 'sellerId', as: 'seller' });

// Category <-> Product (1:M)
Category.hasMany(Product, { foreignKey: 'categoryId', as: 'products' });
Product.belongsTo(Category, { foreignKey: 'categoryId', as: 'category' });

// Product <-> ProductImage (1:M)
Product.hasMany(ProductImage, { foreignKey: 'productId', as: 'images' });
ProductImage.belongsTo(Product, { foreignKey: 'productId', as: 'product' });

// Order <-> OrderItem (1:M)
Order.hasMany(OrderItem, { foreignKey: 'orderId', as: 'items' });
OrderItem.belongsTo(Order, { foreignKey: 'orderId', as: 'order' });

// Product <-> OrderItem (1:M) - An OrderItem contains one Product
Product.hasMany(OrderItem, { foreignKey: 'productId', as: 'orderItems' }); // Optional: allows finding order items for a product
OrderItem.belongsTo(Product, { foreignKey: 'productId', as: 'product' });

// User (Customer) <-> Review (1:M)
User.hasMany(Review, { foreignKey: 'customerId', as: 'reviews' });
Review.belongsTo(User, { foreignKey: 'customerId', as: 'customer' });

// Product <-> Review (1:M)
Product.hasMany(Review, { foreignKey: 'productId', as: 'reviews' });
Review.belongsTo(Product, { foreignKey: 'productId', as: 'product' });


// Export models and sequelize instance
module.exports = {
    sequelize,
    User,
    Seller,
    Category,
    Product,
    ProductImage,
    Order,
    OrderItem,
    Review,
    // Add other models here
};

// Optional: Authenticate database connection on load
sequelize.authenticate()
    .then(() => {
        console.log('Database connection has been established successfully.');
    })
    .catch(err => {
        console.error('Unable to connect to the database:', err);
    });
```

```
code/backend/src/models/category.js
```
module.exports = (sequelize, DataTypes) => {
    const Category = sequelize.define('Category', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true
        },
        description: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'categories'
    });

    // Associations defined in index.js
    // Category.associate = (models) => {
    //     Category.hasMany(models.Product, { foreignKey: 'categoryId', as: 'products' });
    // };

    return Category;
};
```

```
code/backend/src/models/order.js
```
module.exports = (sequelize, DataTypes) => {
    const Order = sequelize.define('Order', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        customerId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'users', // refers to table name
                key: 'id'
            }
        },
        orderDate: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        status: {
            type: DataTypes.ENUM('Pending', 'Processing', 'Shipped', 'Delivered', 'Cancelled'),
            allowNull: false,
            defaultValue: 'Pending'
        },
        shippingAddress: {
            type: DataTypes.JSONB, // Store address as JSON
            allowNull: false
        },
        paymentStatus: {
            type: DataTypes.ENUM('Pending', 'Paid', 'Failed', 'Refunded'),
            allowNull: false,
            defaultValue: 'Pending'
        },
        totalAmount: {
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false
             // This should be calculated and stored at order creation time
        },
        trackingNumber: {
            type: DataTypes.STRING,
            allowNull: true
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'orders'
    });

    // Associations defined in index.js
    // Order.associate = (models) => {
    //     Order.belongsTo(models.User, { foreignKey: 'customerId', as: 'customer' });
    //     Order.hasMany(models.OrderItem, { foreignKey: 'orderId', as: 'items' });
    // };

    return Order;
};
```

```
code/backend/src/models/orderitem.js
```
module.exports = (sequelize, DataTypes) => {
    const OrderItem = sequelize.define('OrderItem', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        orderId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'orders', // refers to table name
                key: 'id'
            }
        },
        productId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'products', // refers to table name
                key: 'id'
            }
        },
        quantity: {
            type: DataTypes.INTEGER,
            allowNull: false,
            validate: {
                min: 1
            }
        },
        priceAtOrder: { // Price of the product at the time the order was placed
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false
        },
        // Optionally store variations selected at order time as JSONB
        // variations: {
        //     type: DataTypes.JSONB,
        //     allowNull: true
        // },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'order_items'
    });

    // Associations defined in index.js
    // OrderItem.associate = (models) => {
    //     OrderItem.belongsTo(models.Order, { foreignKey: 'orderId', as: 'order' });
    //     OrderItem.belongsTo(models.Product, { foreignKey: 'productId', as: 'product' });
    // };

    return OrderItem;
};
```

```
code/backend/src/models/product.js
```
module.exports = (sequelize, DataTypes) => {
    const Product = sequelize.define('Product', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        sellerId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'sellers', // refers to table name
                key: 'id'
            }
        },
        categoryId: {
            type: DataTypes.INTEGER,
            allowNull: false,
             references: {
                model: 'categories', // refers to table name
                key: 'id'
            }
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false
        },
        description: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        price: {
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false,
            validate: {
                min: 0
            }
        },
        stock: {
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 0,
             validate: {
                min: 0
            }
        },
        // status for admin moderation (e.g., 'pending', 'approved', 'rejected')
        moderationStatus: {
            type: DataTypes.ENUM('Pending', 'Approved', 'Rejected'),
            allowNull: false,
            defaultValue: 'Pending'
        },
        isActive: { // Set to true by admin after approval, can be set false by seller (draft/inactive)
            type: DataTypes.BOOLEAN,
            allowNull: false,
            defaultValue: false
        },
        // Optional: Store variations like size, color as JSONB
        // variations: {
        //     type: DataTypes.JSONB,
        //     allowNull: true
        // },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'products'
    });

    // Associations defined in index.js
    // Product.associate = (models) => {
    //     Product.belongsTo(models.Seller, { foreignKey: 'sellerId', as: 'seller' });
    //     Product.belongsTo(models.Category, { foreignKey: 'categoryId', as: 'category' });
    //     Product.hasMany(models.ProductImage, { foreignKey: 'productId', as: 'images' });
    //     Product.hasMany(models.OrderItem, { foreignKey: 'productId', as: 'orderItems' }); // Optional
    //     Product.hasMany(models.Review, { foreignKey: 'productId', as: 'reviews' });
    // };

    return Product;
};
```

```
code/backend/src/models/productimage.js
```
module.exports = (sequelize, DataTypes) => {
    const ProductImage = sequelize.define('ProductImage', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        productId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'products', // refers to table name
                key: 'id'
            }
        },
        imageUrl: {
            type: DataTypes.STRING, // URL to the image stored in S3 or locally
            allowNull: false,
            validate: {
                isUrl: true // Basic URL validation
            }
        },
        // Optional: Store public ID if using a service like Cloudinary
        // publicId: {
        //     type: DataTypes.STRING,
        //     allowNull: true
        // },
        order: { // To maintain display order of images
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 0
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'product_images'
    });

    // Associations defined in index.js
    // ProductImage.associate = (models) => {
    //     ProductImage.belongsTo(models.Product, { foreignKey: 'productId', as: 'product' });
    // };

    return ProductImage;
};
```

```
code/backend/src/models/review.js
```
module.exports = (sequelize, DataTypes) => {
    const Review = sequelize.define('Review', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        productId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'products', // refers to table name
                key: 'id'
            }
        },
        customerId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
                model: 'users', // refers to table name
                key: 'id'
            }
        },
        rating: {
            type: DataTypes.INTEGER,
            allowNull: false,
            validate: {
                min: 1,
                max: 5
            }
        },
        comment: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        reviewDate: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'reviews',
        indexes: [
            // Prevent a customer from reviewing the same product multiple times
            // unless business logic allows it (e.g., one review per purchase)
            // The purchase check needs to be in the service/controller logic.
            // A simple unique constraint here would prevent *any* subsequent review by the same user.
            // {
            //     unique: true,
            //     fields: ['productId', 'customerId']
            // }
        ]
    });

    // Associations defined in index.js
    // Review.associate = (models) => {
    //     Review.belongsTo(models.Product, { foreignKey: 'productId', as: 'product' });
    //     Review.belongsTo(models.User, { foreignKey: 'customerId', as: 'customer' });
    // };

    return Review;
};
```

```
code/backend/src/models/seller.js
```
module.exports = (sequelize, DataTypes) => {
    const Seller = sequelize.define('Seller', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        userId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            unique: true, // Each user can only be one seller
            references: {
                model: 'users', // refers to table name
                key: 'id'
            }
        },
        shopName: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true
        },
        description: {
            type: DataTypes.TEXT,
            allowNull: true
        },
        shopImage: { // URL to shop logo/banner
            type: DataTypes.STRING,
            allowNull: true,
             validate: {
                isUrl: true // Basic URL validation
            }
        },
        // Optional: Add other seller-specific info like policies, location, etc.
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'sellers'
    });

    // Associations defined in index.js
    // Seller.associate = (models) => {
    //     Seller.belongsTo(models.User, { foreignKey: 'userId', as: 'user' });
    //     Seller.hasMany(models.Product, { foreignKey: 'sellerId', as: 'products' });
    // };

    return Seller;
};
```

```
code/backend/src/models/user.js
```
module.exports = (sequelize, DataTypes) => {
    const User = sequelize.define('User', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        email: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true,
            validate: {
                isEmail: true
            }
        },
        passwordHash: {
            type: DataTypes.STRING,
            allowNull: false
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false
        },
        role: {
            type: DataTypes.ENUM('customer', 'seller', 'admin'),
            allowNull: false,
            defaultValue: 'customer'
        },
        // Optional: Profile picture URL, phone number, addresses (can be separate table)
        createdAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updatedAt: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        }
    }, {
        tableName: 'users',
        hooks: {
            // TODO: Add hooks for hashing password BEFORE saving (see authUtils)
            // beforeCreate: async (user) => { ... },
            // beforeUpdate: async (user) => { ... }
        }
    });

    // Associations defined in index.js
    // User.associate = (models) => {
    //     User.hasMany(models.Order, { foreignKey: 'customerId', as: 'orders' });
    //     User.hasOne(models.Seller, { foreignKey: 'userId', as: 'seller' });
    //     User.hasMany(models.Review, { foreignKey: 'customerId', as: 'reviews' });
    // };

    return User;
};
```

```
code/backend/src/routes/adminRoutes.js
```
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const { protect, requireRole } = require('../middleware/authMiddleware');

// All admin routes should be protected and require the 'admin' role
router.use(protect);
router.use(requireRole('admin'));

// User Management
router.get('/users', adminController.getAllUsers);
router.get('/users/:userId', adminController.getUserById);
router.put('/users/:userId', adminController.updateUser);
router.delete('/users/:userId', adminController.deleteUser);

// Product Management (Moderation, Deletion)
router.get('/products', adminController.getAllProducts);
router.get('/products/:productId', adminController.getProductById);
router.put('/products/:productId', adminController.moderateProduct); // Endpoint to change status/isActive
router.delete('/products/:productId', adminController.deleteProduct);

// Order Management
router.get('/orders', adminController.getAllOrders);
router.get('/orders/:orderId', adminController.getOrderById);
router.put('/orders/:orderId/status', adminController.updateOrderStatus); // Endpoint to change order status

// Category Management (TODO: Implement controllers)
// router.get('/categories', adminController.getAllCategories);
// router.post('/categories', adminController.createCategory);
// router.put('/categories/:categoryId', adminController.updateCategory);
// router.delete('/categories/:categoryId', adminController.deleteCategory);

module.exports = router;
```

```
code/backend/src/routes/authRoutes.js
```
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

router.post('/register', authController.registerUser);
router.post('/login', authController.loginUser);

// TODO: Add password reset routes

module.exports = router;
```

```
code/backend/src/routes/index.js
```
const express = require('express');
const router = express.Router();

// Import individual route modules
const authRoutes = require('./authRoutes');
const userRoutes = require('./userRoutes');
const productRoutes = require('./productRoutes');
const orderRoutes = require('./orderRoutes');
const reviewRoutes = require('./reviewRoutes');
const adminRoutes = require('./adminRoutes');

// Mount routes
router.use('/auth', authRoutes);
router.use('/users', userRoutes); // User specific actions (profile)
router.use('/products', productRoutes);
router.use('/orders', orderRoutes); // Customer and Seller order views/updates
router.use('/reviews', reviewRoutes);
router.use('/admin', adminRoutes); // Admin panel routes

module.exports = router;
```

```
code/backend/src/routes/orderRoutes.js
```
const express = require('express');
const router = express.Router();
const orderController = require('../controllers/orderController');
const { protect, requireRole } = require('../middleware/authMiddleware');

// Protect all order routes
router.use(protect);

// Customer routes
router.post('/', requireRole('customer'), orderController.createOrder); // Create a new order from cart
router.get('/me', requireRole('customer'), orderController.getCustomerOrders); // Get orders for the logged-in customer

// Seller routes
router.get('/seller', requireRole('seller'), orderController.getSellerOrders); // Get orders for the logged-in seller

// Shared route (Customer/Seller/Admin can view details if authorized)
router.get('/:orderId', orderController.getOrderDetails);

// Update status (Typically by Seller or Admin)
router.put('/:orderId/status', requireRole(['seller', 'admin']), orderController.updateOrderStatus);


module.exports = router;
```

```
code/backend/src/routes/productRoutes.js
```
const express = require('express');
const router = express.Router();
const productController = require('../controllers/productController');
const { protect, requireRole } = require('../middleware/authMiddleware');
const multer = require('multer'); // For handling file uploads

// Configure multer for image uploads (example using memory storage)
// TODO: Configure actual storage (disk, S3) and file size/type limits
const upload = multer({ storage: multer.memoryStorage() });


// Public routes
router.get('/', productController.getProducts); // Get all products with filters/search
router.get('/:productId', productController.getProductById); // Get single product details
router.get('/categories', productController.getCategories); // Get all categories

// Seller routes (protected, requires seller role)
router.post('/', protect, requireRole('seller'), upload.array('images', 10), productController.createProduct); // Create new product with images
router.put('/:productId', protect, requireRole('seller'), upload.array('images', 10), productController.updateProduct); // Update product details and images
router.delete('/:productId', protect, requireRole('seller'), productController.deleteProduct); // Delete product

// TODO: Add route for getting products by a specific seller ID
// TODO: Add route for featured products
```

```
code/backend/src/routes/reviewRoutes.js
```
const express = require('express');
const router = express.Router({ mergeParams: true }); // mergeParams to access parent route params like :productId
const reviewController = require('../controllers/reviewController');
const { protect, requireRole } = require('../middleware/authMiddleware');

// Get reviews for a specific product (public)
router.get('/', reviewController.getReviewsForProduct);

// Create a review (protected, requires customer role)
router.post('/', protect, requireRole('customer'), reviewController.createReview);

// TODO: Add routes for updating and deleting reviews (protected, requires customer or admin role)

module.exports = router;
```

```
code/backend/src/routes/userRoutes.js
```
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const { protect } = require('../middleware/authMiddleware');

// Protect user profile routes
router.use(protect);

// Get logged-in user's profile
router.get('/me', userController.getUserProfile);

// Update logged-in user's profile
router.put('/me', userController.updateUserProfile);

// TODO: Add routes for managing addresses, wishlist, etc.
// TODO: Add seller specific profile routes (e.g., GET /api/v1/users/seller/me, PUT /api/v1/users/seller/me)
```

```
code/backend/src/services/adminService.js
```
const { User, Product, Order, Seller, Category, ProductImage, OrderItem } = require('../models'); // Import all necessary models

// User Management
exports.findAllUsers = async () => {
    // TODO: Implement filtering, sorting, pagination
    return User.findAll({
        attributes: ['id', 'email', 'name', 'role', 'createdAt', 'updatedAt'], // Exclude passwordHash
        include: { model: Seller, as: 'seller', attributes: ['id', 'shopName'] } // Include basic seller info
    });
};

exports.findUserById = async (userId) => {
    return User.findByPk(userId, {
         attributes: ['id', 'email', 'name', 'role', 'createdAt', 'updatedAt'], // Exclude passwordHash
         include: { model: Seller, as: 'seller', attributes: ['id', 'shopName', 'description', 'shopImage'] }
    });
};

exports.updateUser = async (userId, updateData) => {
    // TODO: Validate updateData - admins might update roles, but sensitive fields need care
    const user = await User.findByPk(userId);
    if (!user) {
        return null; // User not found
    }
    // Prevent changing password directly via this route unless specifically handled
    if (updateData.password) {
        // TODO: Hash new password before updating
        // updateData.passwordHash = await hashPassword(updateData.password);
        delete updateData.password; // Ensure raw password isn't saved
    }

    // Update user fields
    await user.update(updateData);

    // If role is changed to seller and no seller profile exists, create one (basic)
    if (updateData.role === '